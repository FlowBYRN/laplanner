/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.11.3.0 (NJsonSchema v10.4.4.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { AuthorizationService } from 'src/app/services/authorization.service';
import { ClientBase } from './base.service';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class OidcConfigurationClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthorizationService) configuration: AuthorizationService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    configurationData(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/v1/configuration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processConfigurationData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfigurationData(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processConfigurationData(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

@Injectable()
export class TrainingsAppointmentClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthorizationService) configuration: AuthorizationService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllAppointments(): Observable<TrainingsAppointmentDto[]> {
        let url_ = this.baseUrl + "/api/v1/appointments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllAppointments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAppointments(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsAppointmentDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsAppointmentDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAppointments(response: HttpResponseBase): Observable<TrainingsAppointmentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsAppointmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsAppointmentDto[]>(<any>null);
    }

    createAppointment(trainingsAppointment: TrainingsAppointmentDto): Observable<TrainingsAppointmentDto> {
        let url_ = this.baseUrl + "/api/v1/appointments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsAppointment);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateAppointment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAppointment(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsAppointmentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsAppointmentDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAppointment(response: HttpResponseBase): Observable<TrainingsAppointmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TrainingsAppointmentDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsAppointmentDto>(<any>null);
    }

    updateAppointment(trainingsAppointment: TrainingsAppointmentDto): Observable<TrainingsAppointmentDto> {
        let url_ = this.baseUrl + "/api/v1/appointments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsAppointment);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateAppointment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAppointment(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsAppointmentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsAppointmentDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAppointment(response: HttpResponseBase): Observable<TrainingsAppointmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsAppointmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsAppointmentDto>(<any>null);
    }

    deleteAppointment(trainingsAppointment: TrainingsAppointmentDto): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/appointments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsAppointment);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteAppointment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAppointment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAppointment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getAppointmentById(id: number): Observable<TrainingsAppointmentDto> {
        let url_ = this.baseUrl + "/api/v1/appointments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAppointmentById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppointmentById(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsAppointmentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsAppointmentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppointmentById(response: HttpResponseBase): Observable<TrainingsAppointmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsAppointmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsAppointmentDto>(<any>null);
    }

    /**
     * Returns the TrainingsAppointments of spcified User
     * @return The TrainingsModule
     */
    getTrainingsAppointmentsByUserId(userId: string | null): Observable<TrainingsAppointmentDto[]> {
        let url_ = this.baseUrl + "/api/v1/appointments/byUser/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTrainingsAppointmentsByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrainingsAppointmentsByUserId(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsAppointmentDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsAppointmentDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrainingsAppointmentsByUserId(response: HttpResponseBase): Observable<TrainingsAppointmentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsAppointmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsAppointmentDto[]>(<any>null);
    }

    getModulesByAppointmentId(id: number): Observable<TrainingsModuleDto[]> {
        let url_ = this.baseUrl + "/api/v1/appointments/{id}/modules";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetModulesByAppointmentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModulesByAppointmentId(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsModuleDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsModuleDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetModulesByAppointmentId(response: HttpResponseBase): Observable<TrainingsModuleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsModuleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleDto[]>(<any>null);
    }

    addModuleToAppointment(trainingsAppointmentId: number, moduleDtos: TrainingsModuleDto[]): Observable<TrainingsAppointmentTrainingsModuleDto[]> {
        let url_ = this.baseUrl + "/api/v1/appointments/{trainingsAppointmentId}";
        if (trainingsAppointmentId === undefined || trainingsAppointmentId === null)
            throw new Error("The parameter 'trainingsAppointmentId' must be defined.");
        url_ = url_.replace("{trainingsAppointmentId}", encodeURIComponent("" + trainingsAppointmentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(moduleDtos);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAddModuleToAppointment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddModuleToAppointment(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsAppointmentTrainingsModuleDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsAppointmentTrainingsModuleDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processAddModuleToAppointment(response: HttpResponseBase): Observable<TrainingsAppointmentTrainingsModuleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201!.push(TrainingsAppointmentTrainingsModuleDto.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsAppointmentTrainingsModuleDto[]>(<any>null);
    }

    deleteAppointmentWithModule(appointmentId: number, moduleId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/appointments/{appointmentId}/modules/{moduleId}";
        if (appointmentId === undefined || appointmentId === null)
            throw new Error("The parameter 'appointmentId' must be defined.");
        url_ = url_.replace("{appointmentId}", encodeURIComponent("" + appointmentId));
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteAppointmentWithModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAppointmentWithModule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAppointmentWithModule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 202) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TrainingsExerciseClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthorizationService) configuration: AuthorizationService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Creates new TrainingsExercise from Body
     * @param trainingsExercise New TrainingsExercise from HTTP-Body
     * @return The newly created TrainingsExercise
     */
    createExercise(trainingsExercise: TrainingsExerciseDto): Observable<TrainingsExerciseDto> {
        let url_ = this.baseUrl + "/api/v1/trainingsexercises";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsExercise);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateExercise(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateExercise(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsExerciseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsExerciseDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateExercise(response: HttpResponseBase): Observable<TrainingsExerciseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TrainingsExerciseDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsExerciseDto>(<any>null);
    }

    /**
     * Returns all Exercises
     * @return All TrainingsExercises
     */
    readAllExercises(): Observable<TrainingsExerciseDto[]> {
        let url_ = this.baseUrl + "/api/v1/trainingsexercises";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processReadAllExercises(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllExercises(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsExerciseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsExerciseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllExercises(response: HttpResponseBase): Observable<TrainingsExerciseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsExerciseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsExerciseDto[]>(<any>null);
    }

    /**
     * Updates the TrainingsExercise with the given Id
     * @param trainingsExercise The TrainingsExercise with updated values (from HTTP-Body)
     * @return The updated TrainingsExercise
     */
    updateExercise(trainingsExercise: TrainingsExerciseDto): Observable<TrainingsExerciseDto> {
        let url_ = this.baseUrl + "/api/v1/trainingsexercises";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsExercise);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateExercise(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateExercise(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsExerciseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsExerciseDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateExercise(response: HttpResponseBase): Observable<TrainingsExerciseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsExerciseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsExerciseDto>(<any>null);
    }

    /**
     * Deletes the given TrainingsExercise
     * @param trainingsExercise The TrainingsExercise to delete
     * @return The deleted TrainingsExercise
     */
    deleteExercise(trainingsExercise: TrainingsExerciseDto): Observable<TrainingsExerciseDto> {
        let url_ = this.baseUrl + "/api/v1/trainingsexercises";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsExercise);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteExercise(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteExercise(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsExerciseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsExerciseDto>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteExercise(response: HttpResponseBase): Observable<TrainingsExerciseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsExerciseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsExerciseDto>(<any>null);
    }

    /**
     * Returns the TrainingsExercise with the given Id
     * @param trainingsExerciseId Id of the required TrainingsExercise
     * @return The TrainingsExercise
     */
    readExerciseById(trainingsExerciseId: number): Observable<TrainingsExerciseDto> {
        let url_ = this.baseUrl + "/api/v1/trainingsexercises/{trainingsExerciseId}";
        if (trainingsExerciseId === undefined || trainingsExerciseId === null)
            throw new Error("The parameter 'trainingsExerciseId' must be defined.");
        url_ = url_.replace("{trainingsExerciseId}", encodeURIComponent("" + trainingsExerciseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processReadExerciseById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadExerciseById(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsExerciseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsExerciseDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadExerciseById(response: HttpResponseBase): Observable<TrainingsExerciseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsExerciseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsExerciseDto>(<any>null);
    }

    /**
     * Returns the TrainingsExercise with the given Id
     * @param trainingsModuleId Id of the required TrainingsModule
     * @return The TrainingsExercise
     */
    readExercisesByModuleId(trainingsModuleId: number): Observable<TrainingsExerciseDto[]> {
        let url_ = this.baseUrl + "/api/v1/trainingsexercises/modules/{trainingsModuleId}";
        if (trainingsModuleId === undefined || trainingsModuleId === null)
            throw new Error("The parameter 'trainingsModuleId' must be defined.");
        url_ = url_.replace("{trainingsModuleId}", encodeURIComponent("" + trainingsModuleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processReadExercisesByModuleId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadExercisesByModuleId(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsExerciseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsExerciseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadExercisesByModuleId(response: HttpResponseBase): Observable<TrainingsExerciseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsExerciseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsExerciseDto[]>(<any>null);
    }
}

@Injectable()
export class TrainingsGroupClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthorizationService) configuration: AuthorizationService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllGroups(): Observable<TrainingsGroupDto[]> {
        let url_ = this.baseUrl + "/api/v1/groups";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGroups(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsGroupDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsGroupDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllGroups(response: HttpResponseBase): Observable<TrainingsGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsGroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsGroupDto[]>(<any>null);
    }

    createGroup(trainingsGroupDto: TrainingsGroupDto): Observable<TrainingsGroupDto> {
        let url_ = this.baseUrl + "/api/v1/groups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsGroupDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateGroup(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsGroupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsGroupDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateGroup(response: HttpResponseBase): Observable<TrainingsGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsGroupDto>(<any>null);
    }

    updateGroup(trainingsGroupDto: TrainingsGroupDto): Observable<TrainingsGroupDto> {
        let url_ = this.baseUrl + "/api/v1/groups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsGroupDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGroup(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsGroupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsGroupDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGroup(response: HttpResponseBase): Observable<TrainingsGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsGroupDto>(<any>null);
    }

    deleteGroup(trainingsGroupDto: TrainingsGroupDto): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/groups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsGroupDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGroup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteGroup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getGroupById(id: number): Observable<TrainingsGroupDto> {
        let url_ = this.baseUrl + "/api/v1/groups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGroupById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroupById(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsGroupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsGroupDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGroupById(response: HttpResponseBase): Observable<TrainingsGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsGroupDto>(<any>null);
    }

    getAppointmentsByGroupId(id: number): Observable<TrainingsAppointmentDto[]> {
        let url_ = this.baseUrl + "/api/v1/groups/{id}/appointments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAppointmentsByGroupId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppointmentsByGroupId(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsAppointmentDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsAppointmentDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppointmentsByGroupId(response: HttpResponseBase): Observable<TrainingsAppointmentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsAppointmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsAppointmentDto[]>(<any>null);
    }
}

@Injectable()
export class TrainingsGroupUserClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthorizationService) configuration: AuthorizationService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    addUserToGroup(trainingsGroupApplicationUserDto: TrainingsGroupApplicationUserDto): Observable<number> {
        let url_ = this.baseUrl + "/api/v1/groupusers/athlete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsGroupApplicationUserDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAddUserToGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUserToGroup(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddUserToGroup(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    addTrainerToGroup(trainingsGroupApplicationUserDto: TrainingsGroupApplicationUserDto): Observable<number> {
        let url_ = this.baseUrl + "/api/v1/groupusers/trainer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsGroupApplicationUserDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAddTrainerToGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTrainerToGroup(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddTrainerToGroup(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    deleteMemberFromGroup(trainingsGroupId: number | undefined, userId: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/v1/groupusers?";
        if (trainingsGroupId === null)
            throw new Error("The parameter 'trainingsGroupId' cannot be null.");
        else if (trainingsGroupId !== undefined)
            url_ += "trainingsGroupId=" + encodeURIComponent("" + trainingsGroupId) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMemberFromGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMemberFromGroup(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMemberFromGroup(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class TrainingsModuleClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthorizationService) configuration: AuthorizationService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Creates a new TrainingsModule from Body
     * @param trainingsModule Id of the needed TrainingsModule
     * @return The TrainingsModule
     */
    createTrainingsModule(trainingsModule: TrainingsModuleDto): Observable<TrainingsModuleDto> {
        let url_ = this.baseUrl + "/api/v1/modules";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsModule);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateTrainingsModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTrainingsModule(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsModuleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsModuleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTrainingsModule(response: HttpResponseBase): Observable<TrainingsModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TrainingsModuleDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleDto>(<any>null);
    }

    /**
     * Updates the TrainingsModule with the given Id
     * @param trainingsModule The TrainingsModule with updated values (from HTTP-Body)
     * @return The updated TrainingsModule
     */
    updateTrainingsModule(trainingsModule: TrainingsModuleDto): Observable<TrainingsModuleDto> {
        let url_ = this.baseUrl + "/api/v1/modules";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsModule);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateTrainingsModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTrainingsModule(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsModuleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsModuleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTrainingsModule(response: HttpResponseBase): Observable<TrainingsModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsModuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleDto>(<any>null);
    }

    /**
     * Deletes the TrainingsModule with the given Id
     * @param trainingsModule The TrainingsModule with updated values (from HTTP-Body)
     * @return The deleted TrainingsModule
     */
    deleteTrainingsModule(trainingsModule: TrainingsModuleDto): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/modules";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsModule);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteTrainingsModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTrainingsModule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTrainingsModule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Returns all TrainingsModules
     * @return All TrainingsModules
     */
    getAllTrainingsModules(): Observable<TrainingsModuleDto[]> {
        let url_ = this.baseUrl + "/api/v1/modules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllTrainingsModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTrainingsModules(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsModuleDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsModuleDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTrainingsModules(response: HttpResponseBase): Observable<TrainingsModuleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsModuleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleDto[]>(<any>null);
    }

    /**
     * Adds Exercise to a specific Module
     * @param moduleId (optional) Id of the needed TrainingsModule
     * @param exerciseId (optional) Id of the needed Exercise
     * @return TrainingsModuleTrainingsExerciseDto
     */
    addExerciseToModule(moduleId: number | undefined, exerciseId: number | undefined): Observable<TrainingsModuleTrainingsExerciseDto> {
        let url_ = this.baseUrl + "/api/v1/modules/exercisemodule?";
        if (moduleId === null)
            throw new Error("The parameter 'moduleId' cannot be null.");
        else if (moduleId !== undefined)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        if (exerciseId === null)
            throw new Error("The parameter 'exerciseId' cannot be null.");
        else if (exerciseId !== undefined)
            url_ += "exerciseId=" + encodeURIComponent("" + exerciseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAddExerciseToModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddExerciseToModule(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsModuleTrainingsExerciseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsModuleTrainingsExerciseDto>><any>_observableThrow(response_);
        }));
    }

    protected processAddExerciseToModule(response: HttpResponseBase): Observable<TrainingsModuleTrainingsExerciseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TrainingsModuleTrainingsExerciseDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleTrainingsExerciseDto>(<any>null);
    }

    /**
     * Adds Tag to a specific Module
     * @param moduleId (optional) Id of the needed TrainingsModule
     * @param tagId (optional) the needed Exercise
     * @return TrainingsModuleTrainingsExerciseDto
     */
    addTagToModule(moduleId: number | undefined, tagId: number | undefined): Observable<TrainingsModuleTrainingsExerciseDto> {
        let url_ = this.baseUrl + "/tagmodule?";
        if (moduleId === null)
            throw new Error("The parameter 'moduleId' cannot be null.");
        else if (moduleId !== undefined)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        if (tagId === null)
            throw new Error("The parameter 'tagId' cannot be null.");
        else if (tagId !== undefined)
            url_ += "tagId=" + encodeURIComponent("" + tagId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAddTagToModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTagToModule(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsModuleTrainingsExerciseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsModuleTrainingsExerciseDto>><any>_observableThrow(response_);
        }));
    }

    protected processAddTagToModule(response: HttpResponseBase): Observable<TrainingsModuleTrainingsExerciseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TrainingsModuleTrainingsExerciseDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleTrainingsExerciseDto>(<any>null);
    }

    /**
     * Deletes the TrainingsModuleTag with the given Id from the given Module
     * @param moduleId The TrainingsModuleId (from HTTP-Body)
     * @param tagId The TagId(from HTTP-Body)
     * @return The deleted TrainingsModule
     */
    deleteTagByModuleId(moduleId: number, tagId: number): Observable<TrainingsModuleDto> {
        let url_ = this.baseUrl + "/api/v1/modules/{moduleId}/tags/{tagId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (tagId === undefined || tagId === null)
            throw new Error("The parameter 'tagId' must be defined.");
        url_ = url_.replace("{tagId}", encodeURIComponent("" + tagId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteTagByModuleId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTagByModuleId(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsModuleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsModuleDto>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTagByModuleId(response: HttpResponseBase): Observable<TrainingsModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsModuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleDto>(<any>null);
    }

    getAllExercisesByModuleId(id: number): Observable<TrainingsExerciseDto[]> {
        let url_ = this.baseUrl + "/api/v1/modules/{id}/exercises";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllExercisesByModuleId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllExercisesByModuleId(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsExerciseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsExerciseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllExercisesByModuleId(response: HttpResponseBase): Observable<TrainingsExerciseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsExerciseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsExerciseDto[]>(<any>null);
    }

    /**
     * Deletes the Exercise with the given Id from the Module with the given Id
     * @param moduleId The TrainingsModule with updated values (from HTTP-Body)
     * @param exerciseId The TrainingsModule with updated values (from HTTP-Body)
     * @return The deleted TrainingsModule
     */
    deleteExerciseByModuleId(moduleId: number, exerciseId: number): Observable<TrainingsModuleDto> {
        let url_ = this.baseUrl + "/api/v1/modules/{moduleId}/exercises/{exerciseId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (exerciseId === undefined || exerciseId === null)
            throw new Error("The parameter 'exerciseId' must be defined.");
        url_ = url_.replace("{exerciseId}", encodeURIComponent("" + exerciseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteExerciseByModuleId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteExerciseByModuleId(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsModuleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsModuleDto>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteExerciseByModuleId(response: HttpResponseBase): Observable<TrainingsModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsModuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleDto>(<any>null);
    }

    /**
     * Returns all TrainingsModules
     * @param trainingscModuleId (optional) Id of the needed TrainingsModule
     * @return The TrainingsModule
     */
    getTrainingsModuleById(trainingscModuleId: number | undefined, id: string): Observable<TrainingsModuleDto> {
        let url_ = this.baseUrl + "/api/v1/modules/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (trainingscModuleId === null)
            throw new Error("The parameter 'trainingscModuleId' cannot be null.");
        else if (trainingscModuleId !== undefined)
            url_ += "trainingscModuleId=" + encodeURIComponent("" + trainingscModuleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTrainingsModuleById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrainingsModuleById(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsModuleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsModuleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrainingsModuleById(response: HttpResponseBase): Observable<TrainingsModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsModuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleDto>(<any>null);
    }

    /**
     * Returns the TrainingsModule with the given Id
     * @return The TrainingsModule
     */
    getTrainingsModulesByUserId(userId: string | null): Observable<TrainingsModuleDto[]> {
        let url_ = this.baseUrl + "/api/v1/modules/byUser/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTrainingsModulesByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrainingsModulesByUserId(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsModuleDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsModuleDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrainingsModulesByUserId(response: HttpResponseBase): Observable<TrainingsModuleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsModuleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleDto[]>(<any>null);
    }

    /**
     * Returns all TrainingsModules that are part of the given appointment id
     * @param trainingsAppointmentId (optional) Id of the needed TrainingsAppointment
     * @return The TrainingsModule
     */
    getTrainingsModuleByAppointmentId(trainingsAppointmentId: number | undefined, id: string): Observable<TrainingsModuleDto[]> {
        let url_ = this.baseUrl + "/api/v1/modules/appointments/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (trainingsAppointmentId === null)
            throw new Error("The parameter 'trainingsAppointmentId' cannot be null.");
        else if (trainingsAppointmentId !== undefined)
            url_ += "trainingsAppointmentId=" + encodeURIComponent("" + trainingsAppointmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTrainingsModuleByAppointmentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrainingsModuleByAppointmentId(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsModuleDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsModuleDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrainingsModuleByAppointmentId(response: HttpResponseBase): Observable<TrainingsModuleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsModuleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleDto[]>(<any>null);
    }
}

@Injectable()
export class TrainingsModuleTagClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthorizationService) configuration: AuthorizationService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllTags(): Observable<TrainingsModuleTagDto[]> {
        let url_ = this.baseUrl + "/api/v1/tags";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTags(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsModuleTagDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsModuleTagDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTags(response: HttpResponseBase): Observable<TrainingsModuleTagDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsModuleTagDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleTagDto[]>(<any>null);
    }

    createTag(trainingsModuleTagDto: TrainingsModuleTagDto): Observable<TrainingsModuleTagDto> {
        let url_ = this.baseUrl + "/api/v1/tags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsModuleTagDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTag(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsModuleTagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsModuleTagDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTag(response: HttpResponseBase): Observable<TrainingsModuleTagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsModuleTagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleTagDto>(<any>null);
    }

    updateTag(trainingsModuleTagDto: TrainingsModuleTagDto): Observable<TrainingsModuleTagDto> {
        let url_ = this.baseUrl + "/api/v1/tags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsModuleTagDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTag(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsModuleTagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsModuleTagDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTag(response: HttpResponseBase): Observable<TrainingsModuleTagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsModuleTagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleTagDto>(<any>null);
    }

    deleteTag(trainingsModuleTagDto: TrainingsModuleTagDto): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/tags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsModuleTagDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTag(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTag(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getTagById(id: number): Observable<TrainingsModuleTagDto> {
        let url_ = this.baseUrl + "/api/v1/tags/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTagById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTagById(<any>response_);
                } catch (e) {
                    return <Observable<TrainingsModuleTagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingsModuleTagDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTagById(response: HttpResponseBase): Observable<TrainingsModuleTagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsModuleTagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleTagDto>(<any>null);
    }
}

export class TrainingsAppointmentDto implements ITrainingsAppointmentDto {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    userId?: string | undefined;
    endTime?: Date;
    startTime?: Date;
    trainingsGroupId?: number;
    trainingsGroup?: TrainingsGroup | undefined;
    trainingsAppointmentsTrainingsModules?: TrainingsAppointmentTrainingsModule[] | undefined;

    constructor(data?: ITrainingsAppointmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.userId = _data["userId"];
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.trainingsGroupId = _data["trainingsGroupId"];
            this.trainingsGroup = _data["trainingsGroup"] ? TrainingsGroup.fromJS(_data["trainingsGroup"]) : <any>undefined;
            if (Array.isArray(_data["trainingsAppointmentsTrainingsModules"])) {
                this.trainingsAppointmentsTrainingsModules = [] as any;
                for (let item of _data["trainingsAppointmentsTrainingsModules"])
                    this.trainingsAppointmentsTrainingsModules!.push(TrainingsAppointmentTrainingsModule.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TrainingsAppointmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsAppointmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["userId"] = this.userId;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["trainingsGroupId"] = this.trainingsGroupId;
        data["trainingsGroup"] = this.trainingsGroup ? this.trainingsGroup.toJSON() : <any>undefined;
        if (Array.isArray(this.trainingsAppointmentsTrainingsModules)) {
            data["trainingsAppointmentsTrainingsModules"] = [];
            for (let item of this.trainingsAppointmentsTrainingsModules)
                data["trainingsAppointmentsTrainingsModules"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITrainingsAppointmentDto {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    userId?: string | undefined;
    endTime?: Date;
    startTime?: Date;
    trainingsGroupId?: number;
    trainingsGroup?: TrainingsGroup | undefined;
    trainingsAppointmentsTrainingsModules?: TrainingsAppointmentTrainingsModule[] | undefined;
}

export class TrainingsGroup implements ITrainingsGroup {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    trainingsGroupsApplicationUsers?: TrainingsGroupApplicationUser[] | undefined;
    trainingsAppointments?: TrainingsAppointment[] | undefined;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            if (Array.isArray(_data["trainingsGroupsApplicationUsers"])) {
                this.trainingsGroupsApplicationUsers = [] as any;
                for (let item of _data["trainingsGroupsApplicationUsers"])
                    this.trainingsGroupsApplicationUsers!.push(TrainingsGroupApplicationUser.fromJS(item));
            }
            if (Array.isArray(_data["trainingsAppointments"])) {
                this.trainingsAppointments = [] as any;
                for (let item of _data["trainingsAppointments"])
                    this.trainingsAppointments!.push(TrainingsAppointment.fromJS(item));
            }
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsGroup {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        if (Array.isArray(this.trainingsGroupsApplicationUsers)) {
            data["trainingsGroupsApplicationUsers"] = [];
            for (let item of this.trainingsGroupsApplicationUsers)
                data["trainingsGroupsApplicationUsers"].push(item.toJSON());
        }
        if (Array.isArray(this.trainingsAppointments)) {
            data["trainingsAppointments"] = [];
            for (let item of this.trainingsAppointments)
                data["trainingsAppointments"].push(item.toJSON());
        }
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITrainingsGroup {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    trainingsGroupsApplicationUsers?: TrainingsGroupApplicationUser[] | undefined;
    trainingsAppointments?: TrainingsAppointment[] | undefined;
    created?: Date;
    updated?: Date | undefined;
}

export class TrainingsGroupApplicationUser implements ITrainingsGroupApplicationUser {
    trainingsGroupId?: number;
    trainingsGroup?: TrainingsGroup | undefined;
    applicationUserId?: string | undefined;
    isTrainer?: boolean;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsGroupApplicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingsGroupId = _data["trainingsGroupId"];
            this.trainingsGroup = _data["trainingsGroup"] ? TrainingsGroup.fromJS(_data["trainingsGroup"]) : <any>undefined;
            this.applicationUserId = _data["applicationUserId"];
            this.isTrainer = _data["isTrainer"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsGroupApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsGroupApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingsGroupId"] = this.trainingsGroupId;
        data["trainingsGroup"] = this.trainingsGroup ? this.trainingsGroup.toJSON() : <any>undefined;
        data["applicationUserId"] = this.applicationUserId;
        data["isTrainer"] = this.isTrainer;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITrainingsGroupApplicationUser {
    trainingsGroupId?: number;
    trainingsGroup?: TrainingsGroup | undefined;
    applicationUserId?: string | undefined;
    isTrainer?: boolean;
    created?: Date;
    updated?: Date | undefined;
}

export class TrainingsAppointment implements ITrainingsAppointment {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    userId?: string | undefined;
    endTime?: Date;
    startTime?: Date;
    trainingsGroupId?: number;
    trainingsGroup?: TrainingsGroup | undefined;
    trainingsAppointmentsTrainingsModules?: TrainingsAppointmentTrainingsModule[] | undefined;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsAppointment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.userId = _data["userId"];
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.trainingsGroupId = _data["trainingsGroupId"];
            this.trainingsGroup = _data["trainingsGroup"] ? TrainingsGroup.fromJS(_data["trainingsGroup"]) : <any>undefined;
            if (Array.isArray(_data["trainingsAppointmentsTrainingsModules"])) {
                this.trainingsAppointmentsTrainingsModules = [] as any;
                for (let item of _data["trainingsAppointmentsTrainingsModules"])
                    this.trainingsAppointmentsTrainingsModules!.push(TrainingsAppointmentTrainingsModule.fromJS(item));
            }
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsAppointment {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsAppointment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["userId"] = this.userId;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["trainingsGroupId"] = this.trainingsGroupId;
        data["trainingsGroup"] = this.trainingsGroup ? this.trainingsGroup.toJSON() : <any>undefined;
        if (Array.isArray(this.trainingsAppointmentsTrainingsModules)) {
            data["trainingsAppointmentsTrainingsModules"] = [];
            for (let item of this.trainingsAppointmentsTrainingsModules)
                data["trainingsAppointmentsTrainingsModules"].push(item.toJSON());
        }
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITrainingsAppointment {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    userId?: string | undefined;
    endTime?: Date;
    startTime?: Date;
    trainingsGroupId?: number;
    trainingsGroup?: TrainingsGroup | undefined;
    trainingsAppointmentsTrainingsModules?: TrainingsAppointmentTrainingsModule[] | undefined;
    created?: Date;
    updated?: Date | undefined;
}

export class TrainingsAppointmentTrainingsModule implements ITrainingsAppointmentTrainingsModule {
    trainingsModuleId?: number;
    trainingsModule?: TrainingsModule | undefined;
    trainingsAppointmentId?: number;
    trainingsAppointment?: TrainingsAppointment | undefined;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsAppointmentTrainingsModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingsModuleId = _data["trainingsModuleId"];
            this.trainingsModule = _data["trainingsModule"] ? TrainingsModule.fromJS(_data["trainingsModule"]) : <any>undefined;
            this.trainingsAppointmentId = _data["trainingsAppointmentId"];
            this.trainingsAppointment = _data["trainingsAppointment"] ? TrainingsAppointment.fromJS(_data["trainingsAppointment"]) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsAppointmentTrainingsModule {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsAppointmentTrainingsModule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingsModuleId"] = this.trainingsModuleId;
        data["trainingsModule"] = this.trainingsModule ? this.trainingsModule.toJSON() : <any>undefined;
        data["trainingsAppointmentId"] = this.trainingsAppointmentId;
        data["trainingsAppointment"] = this.trainingsAppointment ? this.trainingsAppointment.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITrainingsAppointmentTrainingsModule {
    trainingsModuleId?: number;
    trainingsModule?: TrainingsModule | undefined;
    trainingsAppointmentId?: number;
    trainingsAppointment?: TrainingsAppointment | undefined;
    created?: Date;
    updated?: Date | undefined;
}

export class TrainingsModule implements ITrainingsModule {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    difficulty?: TrainingsDifficulty;
    userId?: string | undefined;
    trainingsModulesTrainingsExercises?: TrainingsModuleTrainingsExercise[] | undefined;
    trainingsModulesTrainingsModuleTags?: TrainingsModuleTrainingsModuleTag[] | undefined;
    trainingsAppointmentsTrainingsModules?: TrainingsAppointmentTrainingsModule[] | undefined;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.difficulty = _data["difficulty"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["trainingsModulesTrainingsExercises"])) {
                this.trainingsModulesTrainingsExercises = [] as any;
                for (let item of _data["trainingsModulesTrainingsExercises"])
                    this.trainingsModulesTrainingsExercises!.push(TrainingsModuleTrainingsExercise.fromJS(item));
            }
            if (Array.isArray(_data["trainingsModulesTrainingsModuleTags"])) {
                this.trainingsModulesTrainingsModuleTags = [] as any;
                for (let item of _data["trainingsModulesTrainingsModuleTags"])
                    this.trainingsModulesTrainingsModuleTags!.push(TrainingsModuleTrainingsModuleTag.fromJS(item));
            }
            if (Array.isArray(_data["trainingsAppointmentsTrainingsModules"])) {
                this.trainingsAppointmentsTrainingsModules = [] as any;
                for (let item of _data["trainingsAppointmentsTrainingsModules"])
                    this.trainingsAppointmentsTrainingsModules!.push(TrainingsAppointmentTrainingsModule.fromJS(item));
            }
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsModule {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsModule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["difficulty"] = this.difficulty;
        data["userId"] = this.userId;
        if (Array.isArray(this.trainingsModulesTrainingsExercises)) {
            data["trainingsModulesTrainingsExercises"] = [];
            for (let item of this.trainingsModulesTrainingsExercises)
                data["trainingsModulesTrainingsExercises"].push(item.toJSON());
        }
        if (Array.isArray(this.trainingsModulesTrainingsModuleTags)) {
            data["trainingsModulesTrainingsModuleTags"] = [];
            for (let item of this.trainingsModulesTrainingsModuleTags)
                data["trainingsModulesTrainingsModuleTags"].push(item.toJSON());
        }
        if (Array.isArray(this.trainingsAppointmentsTrainingsModules)) {
            data["trainingsAppointmentsTrainingsModules"] = [];
            for (let item of this.trainingsAppointmentsTrainingsModules)
                data["trainingsAppointmentsTrainingsModules"].push(item.toJSON());
        }
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITrainingsModule {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    difficulty?: TrainingsDifficulty;
    userId?: string | undefined;
    trainingsModulesTrainingsExercises?: TrainingsModuleTrainingsExercise[] | undefined;
    trainingsModulesTrainingsModuleTags?: TrainingsModuleTrainingsModuleTag[] | undefined;
    trainingsAppointmentsTrainingsModules?: TrainingsAppointmentTrainingsModule[] | undefined;
    created?: Date;
    updated?: Date | undefined;
}

export enum TrainingsDifficulty {
    UNKNOWN = 0,
    EASY = 10,
    MEDIUM = 20,
    HARD = 30,
    IMPOSSIBLE = 40,
}

export class TrainingsModuleTrainingsExercise implements ITrainingsModuleTrainingsExercise {
    trainingsModuleId?: number;
    trainingsModule?: TrainingsModule | undefined;
    trainingsExerciesId?: number;
    trainingsExercise?: TrainingsExercise | undefined;
    position?: number;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsModuleTrainingsExercise) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingsModuleId = _data["trainingsModuleId"];
            this.trainingsModule = _data["trainingsModule"] ? TrainingsModule.fromJS(_data["trainingsModule"]) : <any>undefined;
            this.trainingsExerciesId = _data["trainingsExerciesId"];
            this.trainingsExercise = _data["trainingsExercise"] ? TrainingsExercise.fromJS(_data["trainingsExercise"]) : <any>undefined;
            this.position = _data["position"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsModuleTrainingsExercise {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsModuleTrainingsExercise();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingsModuleId"] = this.trainingsModuleId;
        data["trainingsModule"] = this.trainingsModule ? this.trainingsModule.toJSON() : <any>undefined;
        data["trainingsExerciesId"] = this.trainingsExerciesId;
        data["trainingsExercise"] = this.trainingsExercise ? this.trainingsExercise.toJSON() : <any>undefined;
        data["position"] = this.position;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITrainingsModuleTrainingsExercise {
    trainingsModuleId?: number;
    trainingsModule?: TrainingsModule | undefined;
    trainingsExerciesId?: number;
    trainingsExercise?: TrainingsExercise | undefined;
    position?: number;
    created?: Date;
    updated?: Date | undefined;
}

export class TrainingsExercise implements ITrainingsExercise {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    duration?: number;
    repetitions?: number;
    trainingsModulesTrainingsExercises?: TrainingsModuleTrainingsExercise[] | undefined;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsExercise) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.duration = _data["duration"];
            this.repetitions = _data["repetitions"];
            if (Array.isArray(_data["trainingsModulesTrainingsExercises"])) {
                this.trainingsModulesTrainingsExercises = [] as any;
                for (let item of _data["trainingsModulesTrainingsExercises"])
                    this.trainingsModulesTrainingsExercises!.push(TrainingsModuleTrainingsExercise.fromJS(item));
            }
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsExercise {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsExercise();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["duration"] = this.duration;
        data["repetitions"] = this.repetitions;
        if (Array.isArray(this.trainingsModulesTrainingsExercises)) {
            data["trainingsModulesTrainingsExercises"] = [];
            for (let item of this.trainingsModulesTrainingsExercises)
                data["trainingsModulesTrainingsExercises"].push(item.toJSON());
        }
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITrainingsExercise {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    duration?: number;
    repetitions?: number;
    trainingsModulesTrainingsExercises?: TrainingsModuleTrainingsExercise[] | undefined;
    created?: Date;
    updated?: Date | undefined;
}

export class TrainingsModuleTrainingsModuleTag implements ITrainingsModuleTrainingsModuleTag {
    trainingsModuleId?: number;
    trainingsModule?: TrainingsModule | undefined;
    trainingsModuleTagId?: number;
    trainingsModuleTag?: TrainingsModuleTag | undefined;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsModuleTrainingsModuleTag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingsModuleId = _data["trainingsModuleId"];
            this.trainingsModule = _data["trainingsModule"] ? TrainingsModule.fromJS(_data["trainingsModule"]) : <any>undefined;
            this.trainingsModuleTagId = _data["trainingsModuleTagId"];
            this.trainingsModuleTag = _data["trainingsModuleTag"] ? TrainingsModuleTag.fromJS(_data["trainingsModuleTag"]) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsModuleTrainingsModuleTag {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsModuleTrainingsModuleTag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingsModuleId"] = this.trainingsModuleId;
        data["trainingsModule"] = this.trainingsModule ? this.trainingsModule.toJSON() : <any>undefined;
        data["trainingsModuleTagId"] = this.trainingsModuleTagId;
        data["trainingsModuleTag"] = this.trainingsModuleTag ? this.trainingsModuleTag.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITrainingsModuleTrainingsModuleTag {
    trainingsModuleId?: number;
    trainingsModule?: TrainingsModule | undefined;
    trainingsModuleTagId?: number;
    trainingsModuleTag?: TrainingsModuleTag | undefined;
    created?: Date;
    updated?: Date | undefined;
}

export class TrainingsModuleTag implements ITrainingsModuleTag {
    id?: number;
    title?: string | undefined;
    trainingsModulesTrainingsModuleTags?: TrainingsModuleTrainingsModuleTag[] | undefined;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsModuleTag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            if (Array.isArray(_data["trainingsModulesTrainingsModuleTags"])) {
                this.trainingsModulesTrainingsModuleTags = [] as any;
                for (let item of _data["trainingsModulesTrainingsModuleTags"])
                    this.trainingsModulesTrainingsModuleTags!.push(TrainingsModuleTrainingsModuleTag.fromJS(item));
            }
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsModuleTag {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsModuleTag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        if (Array.isArray(this.trainingsModulesTrainingsModuleTags)) {
            data["trainingsModulesTrainingsModuleTags"] = [];
            for (let item of this.trainingsModulesTrainingsModuleTags)
                data["trainingsModulesTrainingsModuleTags"].push(item.toJSON());
        }
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITrainingsModuleTag {
    id?: number;
    title?: string | undefined;
    trainingsModulesTrainingsModuleTags?: TrainingsModuleTrainingsModuleTag[] | undefined;
    created?: Date;
    updated?: Date | undefined;
}

/** A machine-readable format for specifying errors in HTTP API responses based on https://tools.ietf.org/html/rfc7807. */
export class ProblemDetails implements IProblemDetails {
    /** A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when
dereferenced, it provide human-readable documentation for the problem type
(e.g., using HTML [W3C.REC-html5-20141028]).  When this member is not present, its value is assumed to be
"about:blank". */
    type?: string | undefined;
    /** A short, human-readable summary of the problem type.It SHOULD NOT change from occurrence to occurrence
of the problem, except for purposes of localization(e.g., using proactive content negotiation;
see[RFC7231], Section 3.4). */
    title?: string | undefined;
    /** The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem. */
    status?: number | undefined;
    /** A human-readable explanation specific to this occurrence of the problem. */
    detail?: string | undefined;
    /** A URI reference that identifies the specific occurrence of the problem.It may or may not yield further information if dereferenced. */
    instance?: string | undefined;
    /** Gets the IDictionary`2 for extension members.

Problem type definitions MAY extend the problem details object with additional members. Extension members appear in the same namespace as
other members of a problem type. */
    extensions?: { [key: string]: any; } | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["extensions"]) {
                this.extensions = {} as any;
                for (let key in _data["extensions"]) {
                    if (_data["extensions"].hasOwnProperty(key))
                        (<any>this.extensions)![key] = _data["extensions"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.extensions) {
            data["extensions"] = {};
            for (let key in this.extensions) {
                if (this.extensions.hasOwnProperty(key))
                    (<any>data["extensions"])[key] = this.extensions[key];
            }
        }
        return data; 
    }
}

/** A machine-readable format for specifying errors in HTTP API responses based on https://tools.ietf.org/html/rfc7807. */
export interface IProblemDetails {
    /** A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when
dereferenced, it provide human-readable documentation for the problem type
(e.g., using HTML [W3C.REC-html5-20141028]).  When this member is not present, its value is assumed to be
"about:blank". */
    type?: string | undefined;
    /** A short, human-readable summary of the problem type.It SHOULD NOT change from occurrence to occurrence
of the problem, except for purposes of localization(e.g., using proactive content negotiation;
see[RFC7231], Section 3.4). */
    title?: string | undefined;
    /** The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem. */
    status?: number | undefined;
    /** A human-readable explanation specific to this occurrence of the problem. */
    detail?: string | undefined;
    /** A URI reference that identifies the specific occurrence of the problem.It may or may not yield further information if dereferenced. */
    instance?: string | undefined;
    /** Gets the IDictionary`2 for extension members.

Problem type definitions MAY extend the problem details object with additional members. Extension members appear in the same namespace as
other members of a problem type. */
    extensions?: { [key: string]: any; } | undefined;
}

export class TrainingsModuleDto implements ITrainingsModuleDto {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    difficulty?: TrainingsDifficulty;
    userId?: string | undefined;
    trainingsModulesTrainingsExercises?: TrainingsModuleTrainingsExercise[] | undefined;
    trainingsModulesTrainingsModuleTags?: TrainingsModuleTrainingsModuleTag[] | undefined;
    trainingsAppointmentsTrainingsModules?: TrainingsAppointmentTrainingsModule[] | undefined;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsModuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.difficulty = _data["difficulty"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["trainingsModulesTrainingsExercises"])) {
                this.trainingsModulesTrainingsExercises = [] as any;
                for (let item of _data["trainingsModulesTrainingsExercises"])
                    this.trainingsModulesTrainingsExercises!.push(TrainingsModuleTrainingsExercise.fromJS(item));
            }
            if (Array.isArray(_data["trainingsModulesTrainingsModuleTags"])) {
                this.trainingsModulesTrainingsModuleTags = [] as any;
                for (let item of _data["trainingsModulesTrainingsModuleTags"])
                    this.trainingsModulesTrainingsModuleTags!.push(TrainingsModuleTrainingsModuleTag.fromJS(item));
            }
            if (Array.isArray(_data["trainingsAppointmentsTrainingsModules"])) {
                this.trainingsAppointmentsTrainingsModules = [] as any;
                for (let item of _data["trainingsAppointmentsTrainingsModules"])
                    this.trainingsAppointmentsTrainingsModules!.push(TrainingsAppointmentTrainingsModule.fromJS(item));
            }
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsModuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsModuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["difficulty"] = this.difficulty;
        data["userId"] = this.userId;
        if (Array.isArray(this.trainingsModulesTrainingsExercises)) {
            data["trainingsModulesTrainingsExercises"] = [];
            for (let item of this.trainingsModulesTrainingsExercises)
                data["trainingsModulesTrainingsExercises"].push(item.toJSON());
        }
        if (Array.isArray(this.trainingsModulesTrainingsModuleTags)) {
            data["trainingsModulesTrainingsModuleTags"] = [];
            for (let item of this.trainingsModulesTrainingsModuleTags)
                data["trainingsModulesTrainingsModuleTags"].push(item.toJSON());
        }
        if (Array.isArray(this.trainingsAppointmentsTrainingsModules)) {
            data["trainingsAppointmentsTrainingsModules"] = [];
            for (let item of this.trainingsAppointmentsTrainingsModules)
                data["trainingsAppointmentsTrainingsModules"].push(item.toJSON());
        }
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITrainingsModuleDto {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    difficulty?: TrainingsDifficulty;
    userId?: string | undefined;
    trainingsModulesTrainingsExercises?: TrainingsModuleTrainingsExercise[] | undefined;
    trainingsModulesTrainingsModuleTags?: TrainingsModuleTrainingsModuleTag[] | undefined;
    trainingsAppointmentsTrainingsModules?: TrainingsAppointmentTrainingsModule[] | undefined;
    created?: Date;
    updated?: Date | undefined;
}

export class TrainingsAppointmentTrainingsModuleDto implements ITrainingsAppointmentTrainingsModuleDto {
    trainingsModuleId?: number;
    trainingsModule?: TrainingsModule | undefined;
    trainingsAppointmentId?: number;
    trainingsAppointment?: TrainingsAppointment | undefined;

    constructor(data?: ITrainingsAppointmentTrainingsModuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingsModuleId = _data["trainingsModuleId"];
            this.trainingsModule = _data["trainingsModule"] ? TrainingsModule.fromJS(_data["trainingsModule"]) : <any>undefined;
            this.trainingsAppointmentId = _data["trainingsAppointmentId"];
            this.trainingsAppointment = _data["trainingsAppointment"] ? TrainingsAppointment.fromJS(_data["trainingsAppointment"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsAppointmentTrainingsModuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsAppointmentTrainingsModuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingsModuleId"] = this.trainingsModuleId;
        data["trainingsModule"] = this.trainingsModule ? this.trainingsModule.toJSON() : <any>undefined;
        data["trainingsAppointmentId"] = this.trainingsAppointmentId;
        data["trainingsAppointment"] = this.trainingsAppointment ? this.trainingsAppointment.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITrainingsAppointmentTrainingsModuleDto {
    trainingsModuleId?: number;
    trainingsModule?: TrainingsModule | undefined;
    trainingsAppointmentId?: number;
    trainingsAppointment?: TrainingsAppointment | undefined;
}

export class TrainingsExerciseDto implements ITrainingsExerciseDto {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    duration?: number;
    repetitions?: number;
    trainingsModulesTrainingsExercises?: TrainingsModuleTrainingsExercise[] | undefined;

    constructor(data?: ITrainingsExerciseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.duration = _data["duration"];
            this.repetitions = _data["repetitions"];
            if (Array.isArray(_data["trainingsModulesTrainingsExercises"])) {
                this.trainingsModulesTrainingsExercises = [] as any;
                for (let item of _data["trainingsModulesTrainingsExercises"])
                    this.trainingsModulesTrainingsExercises!.push(TrainingsModuleTrainingsExercise.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TrainingsExerciseDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsExerciseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["duration"] = this.duration;
        data["repetitions"] = this.repetitions;
        if (Array.isArray(this.trainingsModulesTrainingsExercises)) {
            data["trainingsModulesTrainingsExercises"] = [];
            for (let item of this.trainingsModulesTrainingsExercises)
                data["trainingsModulesTrainingsExercises"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITrainingsExerciseDto {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    duration?: number;
    repetitions?: number;
    trainingsModulesTrainingsExercises?: TrainingsModuleTrainingsExercise[] | undefined;
}

export class TrainingsGroupDto implements ITrainingsGroupDto {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    trainingsGroupsApplicationUsers?: TrainingsGroupApplicationUser[] | undefined;
    trainingsAppointments?: TrainingsAppointment[] | undefined;

    constructor(data?: ITrainingsGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            if (Array.isArray(_data["trainingsGroupsApplicationUsers"])) {
                this.trainingsGroupsApplicationUsers = [] as any;
                for (let item of _data["trainingsGroupsApplicationUsers"])
                    this.trainingsGroupsApplicationUsers!.push(TrainingsGroupApplicationUser.fromJS(item));
            }
            if (Array.isArray(_data["trainingsAppointments"])) {
                this.trainingsAppointments = [] as any;
                for (let item of _data["trainingsAppointments"])
                    this.trainingsAppointments!.push(TrainingsAppointment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TrainingsGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        if (Array.isArray(this.trainingsGroupsApplicationUsers)) {
            data["trainingsGroupsApplicationUsers"] = [];
            for (let item of this.trainingsGroupsApplicationUsers)
                data["trainingsGroupsApplicationUsers"].push(item.toJSON());
        }
        if (Array.isArray(this.trainingsAppointments)) {
            data["trainingsAppointments"] = [];
            for (let item of this.trainingsAppointments)
                data["trainingsAppointments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITrainingsGroupDto {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    trainingsGroupsApplicationUsers?: TrainingsGroupApplicationUser[] | undefined;
    trainingsAppointments?: TrainingsAppointment[] | undefined;
}

export class TrainingsGroupApplicationUserDto implements ITrainingsGroupApplicationUserDto {
    trainingsGroupId?: number;
    trainingsGroup?: TrainingsGroup | undefined;
    applicationUserId?: string | undefined;
    isTrainer?: boolean;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsGroupApplicationUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingsGroupId = _data["trainingsGroupId"];
            this.trainingsGroup = _data["trainingsGroup"] ? TrainingsGroup.fromJS(_data["trainingsGroup"]) : <any>undefined;
            this.applicationUserId = _data["applicationUserId"];
            this.isTrainer = _data["isTrainer"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsGroupApplicationUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsGroupApplicationUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingsGroupId"] = this.trainingsGroupId;
        data["trainingsGroup"] = this.trainingsGroup ? this.trainingsGroup.toJSON() : <any>undefined;
        data["applicationUserId"] = this.applicationUserId;
        data["isTrainer"] = this.isTrainer;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITrainingsGroupApplicationUserDto {
    trainingsGroupId?: number;
    trainingsGroup?: TrainingsGroup | undefined;
    applicationUserId?: string | undefined;
    isTrainer?: boolean;
    created?: Date;
    updated?: Date | undefined;
}

export class TrainingsModuleTrainingsExerciseDto implements ITrainingsModuleTrainingsExerciseDto {
    trainingsModuleId?: number;
    trainingsModule?: TrainingsModule | undefined;
    trainingsExerciesId?: number;
    trainingsExercise?: TrainingsExercise | undefined;
    position?: number;

    constructor(data?: ITrainingsModuleTrainingsExerciseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingsModuleId = _data["trainingsModuleId"];
            this.trainingsModule = _data["trainingsModule"] ? TrainingsModule.fromJS(_data["trainingsModule"]) : <any>undefined;
            this.trainingsExerciesId = _data["trainingsExerciesId"];
            this.trainingsExercise = _data["trainingsExercise"] ? TrainingsExercise.fromJS(_data["trainingsExercise"]) : <any>undefined;
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): TrainingsModuleTrainingsExerciseDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsModuleTrainingsExerciseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingsModuleId"] = this.trainingsModuleId;
        data["trainingsModule"] = this.trainingsModule ? this.trainingsModule.toJSON() : <any>undefined;
        data["trainingsExerciesId"] = this.trainingsExerciesId;
        data["trainingsExercise"] = this.trainingsExercise ? this.trainingsExercise.toJSON() : <any>undefined;
        data["position"] = this.position;
        return data; 
    }
}

export interface ITrainingsModuleTrainingsExerciseDto {
    trainingsModuleId?: number;
    trainingsModule?: TrainingsModule | undefined;
    trainingsExerciesId?: number;
    trainingsExercise?: TrainingsExercise | undefined;
    position?: number;
}

export class TrainingsModuleTagDto implements ITrainingsModuleTagDto {
    id?: number;
    title?: string | undefined;
    trainingsModulesTrainingsModuleTags?: TrainingsModuleTrainingsModuleTag[] | undefined;

    constructor(data?: ITrainingsModuleTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            if (Array.isArray(_data["trainingsModulesTrainingsModuleTags"])) {
                this.trainingsModulesTrainingsModuleTags = [] as any;
                for (let item of _data["trainingsModulesTrainingsModuleTags"])
                    this.trainingsModulesTrainingsModuleTags!.push(TrainingsModuleTrainingsModuleTag.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TrainingsModuleTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsModuleTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        if (Array.isArray(this.trainingsModulesTrainingsModuleTags)) {
            data["trainingsModulesTrainingsModuleTags"] = [];
            for (let item of this.trainingsModulesTrainingsModuleTags)
                data["trainingsModulesTrainingsModuleTags"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITrainingsModuleTagDto {
    id?: number;
    title?: string | undefined;
    trainingsModulesTrainingsModuleTags?: TrainingsModuleTrainingsModuleTag[] | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}

// @Injectable({
//   providedIn: 'root'
// })
// export class ClientExtensionService {

//   constructor() {
//    }
// }