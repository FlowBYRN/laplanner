//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { AuthorizeService } from '../api-authorization/authorize.service';
import { ClientBase } from './base.service';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class FollowClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthorizeService) configuration: AuthorizeService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    followModule(moduleId: number | undefined): Observable<TrainingsModuleFollowDto> {
        let url_ = this.baseUrl + "/api/v1/Follow?";
        if (moduleId === null)
            throw new Error("The parameter 'moduleId' cannot be null.");
        else if (moduleId !== undefined)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processFollowModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFollowModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsModuleFollowDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsModuleFollowDto>;
        }));
    }

    protected processFollowModule(response: HttpResponseBase): Observable<TrainingsModuleFollowDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsModuleFollowDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleFollowDto>(null as any);
    }

    unFollowModule(moduleId: number | undefined): Observable<TrainingsModuleFollowDto> {
        let url_ = this.baseUrl + "/api/v1/Follow?";
        if (moduleId === null)
            throw new Error("The parameter 'moduleId' cannot be null.");
        else if (moduleId !== undefined)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUnFollowModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnFollowModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsModuleFollowDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsModuleFollowDto>;
        }));
    }

    protected processUnFollowModule(response: HttpResponseBase): Observable<TrainingsModuleFollowDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsModuleFollowDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleFollowDto>(null as any);
    }

    getFollowers(trainingsModuleId: number | undefined): Observable<TrainingsModuleDto[]> {
        let url_ = this.baseUrl + "/api/v1/Follow/GetFollowers?";
        if (trainingsModuleId === null)
            throw new Error("The parameter 'trainingsModuleId' cannot be null.");
        else if (trainingsModuleId !== undefined)
            url_ += "trainingsModuleId=" + encodeURIComponent("" + trainingsModuleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetFollowers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFollowers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsModuleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsModuleDto[]>;
        }));
    }

    protected processGetFollowers(response: HttpResponseBase): Observable<TrainingsModuleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsModuleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleDto[]>(null as any);
    }

    getFollows(userId: string | null | undefined): Observable<TrainingsModuleDto[]> {
        let url_ = this.baseUrl + "/api/v1/Follow/GetFollows?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetFollows(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFollows(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsModuleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsModuleDto[]>;
        }));
    }

    protected processGetFollows(response: HttpResponseBase): Observable<TrainingsModuleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsModuleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleDto[]>(null as any);
    }
}

@Injectable()
export class OidcConfigurationClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthorizeService) configuration: AuthorizeService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getClientRequestParameters(clientId: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/_configuration/{clientId}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetClientRequestParameters(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientRequestParameters(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetClientRequestParameters(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    configurationData(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/v1/configuration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processConfigurationData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfigurationData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processConfigurationData(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }
}

@Injectable()
export class TrainingsAppointmentClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthorizeService) configuration: AuthorizeService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllAppointments(): Observable<TrainingsAppointmentDto[]> {
        let url_ = this.baseUrl + "/api/v1/appointments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllAppointments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAppointments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsAppointmentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsAppointmentDto[]>;
        }));
    }

    protected processGetAllAppointments(response: HttpResponseBase): Observable<TrainingsAppointmentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsAppointmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsAppointmentDto[]>(null as any);
    }

    createAppointment(trainingsAppointment: TrainingsAppointmentDto): Observable<TrainingsAppointmentDto> {
        let url_ = this.baseUrl + "/api/v1/appointments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsAppointment);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateAppointment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAppointment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsAppointmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsAppointmentDto>;
        }));
    }

    protected processCreateAppointment(response: HttpResponseBase): Observable<TrainingsAppointmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TrainingsAppointmentDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsAppointmentDto>(null as any);
    }

    updateAppointment(trainingsAppointment: TrainingsAppointmentDto): Observable<TrainingsAppointmentDto> {
        let url_ = this.baseUrl + "/api/v1/appointments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsAppointment);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateAppointment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAppointment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsAppointmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsAppointmentDto>;
        }));
    }

    protected processUpdateAppointment(response: HttpResponseBase): Observable<TrainingsAppointmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsAppointmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsAppointmentDto>(null as any);
    }

    deleteAppointment(trainingsAppointment: TrainingsAppointmentDto): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/appointments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsAppointment);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteAppointment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAppointment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAppointment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    getAppointmentById(id: number): Observable<TrainingsAppointmentDto> {
        let url_ = this.baseUrl + "/api/v1/appointments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAppointmentById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppointmentById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsAppointmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsAppointmentDto>;
        }));
    }

    protected processGetAppointmentById(response: HttpResponseBase): Observable<TrainingsAppointmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsAppointmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsAppointmentDto>(null as any);
    }

    getFullAppointmentById(id: number): Observable<TrainingsAppointmentDto> {
        let url_ = this.baseUrl + "/api/v1/appointments/{id}/full";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetFullAppointmentById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFullAppointmentById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsAppointmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsAppointmentDto>;
        }));
    }

    protected processGetFullAppointmentById(response: HttpResponseBase): Observable<TrainingsAppointmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsAppointmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsAppointmentDto>(null as any);
    }

    /**
     * Returns the TrainingsAppointments of spcified User
     * @return The TrainingsModule
     */
    getTrainingsAppointmentsByUserId(userId: string | null): Observable<TrainingsAppointmentDto[]> {
        let url_ = this.baseUrl + "/api/v1/appointments/byUser/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTrainingsAppointmentsByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrainingsAppointmentsByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsAppointmentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsAppointmentDto[]>;
        }));
    }

    protected processGetTrainingsAppointmentsByUserId(response: HttpResponseBase): Observable<TrainingsAppointmentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsAppointmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsAppointmentDto[]>(null as any);
    }

    getModulesByAppointmentId(id: number): Observable<TrainingsModuleDto[]> {
        let url_ = this.baseUrl + "/api/v1/appointments/{id}/modules";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetModulesByAppointmentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModulesByAppointmentId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsModuleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsModuleDto[]>;
        }));
    }

    protected processGetModulesByAppointmentId(response: HttpResponseBase): Observable<TrainingsModuleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsModuleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleDto[]>(null as any);
    }

    addModuleToAppointment(trainingsAppointmentId: number, moduleIds: number[]): Observable<TrainingsAppointmentTrainingsModuleDto[]> {
        let url_ = this.baseUrl + "/api/v1/appointments/{trainingsAppointmentId}";
        if (trainingsAppointmentId === undefined || trainingsAppointmentId === null)
            throw new Error("The parameter 'trainingsAppointmentId' must be defined.");
        url_ = url_.replace("{trainingsAppointmentId}", encodeURIComponent("" + trainingsAppointmentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(moduleIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAddModuleToAppointment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddModuleToAppointment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsAppointmentTrainingsModuleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsAppointmentTrainingsModuleDto[]>;
        }));
    }

    protected processAddModuleToAppointment(response: HttpResponseBase): Observable<TrainingsAppointmentTrainingsModuleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201!.push(TrainingsAppointmentTrainingsModuleDto.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsAppointmentTrainingsModuleDto[]>(null as any);
    }

    deleteAppointmentWithModule(appointmentId: number, moduleId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/appointments/{appointmentId}/modules/{moduleId}";
        if (appointmentId === undefined || appointmentId === null)
            throw new Error("The parameter 'appointmentId' must be defined.");
        url_ = url_.replace("{appointmentId}", encodeURIComponent("" + appointmentId));
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteAppointmentWithModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAppointmentWithModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAppointmentWithModule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 202) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TrainingsExerciseClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthorizeService) configuration: AuthorizeService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Creates new TrainingsExercise from Body
     * @param trainingsExercise New TrainingsExercise from HTTP-Body
     * @return The newly created TrainingsExercise
     */
    createExercise(trainingsExercise: TrainingsExerciseDto): Observable<TrainingsExerciseDto> {
        let url_ = this.baseUrl + "/api/v1/trainingsexercises";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsExercise);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateExercise(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateExercise(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsExerciseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsExerciseDto>;
        }));
    }

    protected processCreateExercise(response: HttpResponseBase): Observable<TrainingsExerciseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TrainingsExerciseDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsExerciseDto>(null as any);
    }

    /**
     * Returns all Exercises
     * @return All TrainingsExercises
     */
    readAllExercises(): Observable<TrainingsExerciseDto[]> {
        let url_ = this.baseUrl + "/api/v1/trainingsexercises";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processReadAllExercises(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllExercises(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsExerciseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsExerciseDto[]>;
        }));
    }

    protected processReadAllExercises(response: HttpResponseBase): Observable<TrainingsExerciseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsExerciseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsExerciseDto[]>(null as any);
    }

    /**
     * Updates the TrainingsExercise with the given Id
     * @param trainingsExercise The TrainingsExercise with updated values (from HTTP-Body)
     * @return The updated TrainingsExercise
     */
    updateExercise(trainingsExercise: TrainingsExerciseDto): Observable<TrainingsExerciseDto> {
        let url_ = this.baseUrl + "/api/v1/trainingsexercises";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsExercise);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateExercise(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateExercise(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsExerciseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsExerciseDto>;
        }));
    }

    protected processUpdateExercise(response: HttpResponseBase): Observable<TrainingsExerciseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsExerciseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsExerciseDto>(null as any);
    }

    /**
     * Deletes the given TrainingsExercise
     * @param trainingsExercise The TrainingsExercise to delete
     * @return The deleted TrainingsExercise
     */
    deleteExercise(trainingsExercise: TrainingsExerciseDto): Observable<TrainingsExerciseDto> {
        let url_ = this.baseUrl + "/api/v1/trainingsexercises";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsExercise);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteExercise(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteExercise(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsExerciseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsExerciseDto>;
        }));
    }

    protected processDeleteExercise(response: HttpResponseBase): Observable<TrainingsExerciseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsExerciseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsExerciseDto>(null as any);
    }

    /**
     * Returns the TrainingsExercise with the given Id
     * @param trainingsExerciseId Id of the required TrainingsExercise
     * @return The TrainingsExercise
     */
    readExerciseById(trainingsExerciseId: number): Observable<TrainingsExerciseDto> {
        let url_ = this.baseUrl + "/api/v1/trainingsexercises/{trainingsExerciseId}";
        if (trainingsExerciseId === undefined || trainingsExerciseId === null)
            throw new Error("The parameter 'trainingsExerciseId' must be defined.");
        url_ = url_.replace("{trainingsExerciseId}", encodeURIComponent("" + trainingsExerciseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processReadExerciseById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadExerciseById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsExerciseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsExerciseDto>;
        }));
    }

    protected processReadExerciseById(response: HttpResponseBase): Observable<TrainingsExerciseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsExerciseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsExerciseDto>(null as any);
    }

    /**
     * Returns the TrainingsExercise with the given Id
     * @param trainingsModuleId Id of the required TrainingsModule
     * @return The TrainingsExercise
     */
    readExercisesByModuleId(trainingsModuleId: number): Observable<TrainingsExerciseDto[]> {
        let url_ = this.baseUrl + "/api/v1/trainingsexercises/modules/{trainingsModuleId}";
        if (trainingsModuleId === undefined || trainingsModuleId === null)
            throw new Error("The parameter 'trainingsModuleId' must be defined.");
        url_ = url_.replace("{trainingsModuleId}", encodeURIComponent("" + trainingsModuleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processReadExercisesByModuleId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadExercisesByModuleId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsExerciseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsExerciseDto[]>;
        }));
    }

    protected processReadExercisesByModuleId(response: HttpResponseBase): Observable<TrainingsExerciseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsExerciseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsExerciseDto[]>(null as any);
    }
}

@Injectable()
export class TrainingsGroupClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthorizeService) configuration: AuthorizeService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllGroups(): Observable<TrainingsGroupDto[]> {
        let url_ = this.baseUrl + "/api/v1/groups";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGroups(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsGroupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsGroupDto[]>;
        }));
    }

    protected processGetAllGroups(response: HttpResponseBase): Observable<TrainingsGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsGroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsGroupDto[]>(null as any);
    }

    createGroup(trainingsGroupDto: TrainingsGroupDto): Observable<TrainingsGroupDto> {
        let url_ = this.baseUrl + "/api/v1/groups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsGroupDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsGroupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsGroupDto>;
        }));
    }

    protected processCreateGroup(response: HttpResponseBase): Observable<TrainingsGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsGroupDto>(null as any);
    }

    updateGroup(trainingsGroupDto: TrainingsGroupDto): Observable<TrainingsGroupDto> {
        let url_ = this.baseUrl + "/api/v1/groups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsGroupDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsGroupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsGroupDto>;
        }));
    }

    protected processUpdateGroup(response: HttpResponseBase): Observable<TrainingsGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsGroupDto>(null as any);
    }

    deleteGroup(trainingsGroupDto: TrainingsGroupDto): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/groups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsGroupDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteGroup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    getGroupById(id: number): Observable<TrainingsGroupDto> {
        let url_ = this.baseUrl + "/api/v1/groups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGroupById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroupById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsGroupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsGroupDto>;
        }));
    }

    protected processGetGroupById(response: HttpResponseBase): Observable<TrainingsGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsGroupDto>(null as any);
    }

    getAppointmentsByGroupId(id: number): Observable<TrainingsAppointmentDto[]> {
        let url_ = this.baseUrl + "/api/v1/groups/{id}/appointments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAppointmentsByGroupId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppointmentsByGroupId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsAppointmentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsAppointmentDto[]>;
        }));
    }

    protected processGetAppointmentsByGroupId(response: HttpResponseBase): Observable<TrainingsAppointmentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsAppointmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsAppointmentDto[]>(null as any);
    }
}

@Injectable()
export class TrainingsGroupUserClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthorizeService) configuration: AuthorizeService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    addUserToGroup(trainingsGroupApplicationUserDto: TrainingsGroupApplicationUserDto): Observable<number> {
        let url_ = this.baseUrl + "/api/v1/groupusers/athlete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsGroupApplicationUserDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAddUserToGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUserToGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processAddUserToGroup(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    addTrainerToGroup(trainingsGroupApplicationUserDto: TrainingsGroupApplicationUserDto): Observable<number> {
        let url_ = this.baseUrl + "/api/v1/groupusers/trainer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsGroupApplicationUserDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAddTrainerToGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTrainerToGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processAddTrainerToGroup(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    deleteMemberFromGroup(trainingsGroupId: number | undefined, userId: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/v1/groupusers?";
        if (trainingsGroupId === null)
            throw new Error("The parameter 'trainingsGroupId' cannot be null.");
        else if (trainingsGroupId !== undefined)
            url_ += "trainingsGroupId=" + encodeURIComponent("" + trainingsGroupId) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMemberFromGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMemberFromGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDeleteMemberFromGroup(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class TrainingsModuleClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthorizeService) configuration: AuthorizeService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Creates a new TrainingsModule from Body
     * @param trainingsModule Id of the needed TrainingsModule
     * @return The TrainingsModule
     */
    createTrainingsModule(trainingsModule: TrainingsModuleDto): Observable<TrainingsModuleDto> {
        let url_ = this.baseUrl + "/api/v1/modules";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsModule);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateTrainingsModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTrainingsModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsModuleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsModuleDto>;
        }));
    }

    protected processCreateTrainingsModule(response: HttpResponseBase): Observable<TrainingsModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TrainingsModuleDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleDto>(null as any);
    }

    /**
     * Updates the TrainingsModule with the given Id
     * @param trainingsModule The TrainingsModule with updated values (from HTTP-Body)
     * @return The updated TrainingsModule
     */
    updateTrainingsModule(trainingsModule: TrainingsModuleDto): Observable<TrainingsModuleDto> {
        let url_ = this.baseUrl + "/api/v1/modules";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsModule);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateTrainingsModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTrainingsModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsModuleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsModuleDto>;
        }));
    }

    protected processUpdateTrainingsModule(response: HttpResponseBase): Observable<TrainingsModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsModuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleDto>(null as any);
    }

    /**
     * Deletes the TrainingsModule with the given Id
     * @param trainingsModule The TrainingsModule with updated values (from HTTP-Body)
     * @return The deleted TrainingsModule
     */
    deleteTrainingsModule(trainingsModule: TrainingsModuleDto): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/modules";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsModule);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteTrainingsModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTrainingsModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteTrainingsModule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Returns all TrainingsModules
     * @return All TrainingsModules
     */
    getAllTrainingsModules(): Observable<TrainingsModuleDto[]> {
        let url_ = this.baseUrl + "/api/v1/modules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllTrainingsModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTrainingsModules(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsModuleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsModuleDto[]>;
        }));
    }

    protected processGetAllTrainingsModules(response: HttpResponseBase): Observable<TrainingsModuleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsModuleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleDto[]>(null as any);
    }

    /**
     * Adds Exercise to a specific Module
     * @param moduleId (optional) Id of the needed TrainingsModule
     * @param exerciseId (optional) Id of the needed Exercise
     * @return TrainingsModuleTrainingsExerciseDto
     */
    addExerciseToModule(moduleId: number | undefined, exerciseId: number | undefined): Observable<TrainingsModuleTrainingsExerciseDto> {
        let url_ = this.baseUrl + "/api/v1/modules/exercisemodule?";
        if (moduleId === null)
            throw new Error("The parameter 'moduleId' cannot be null.");
        else if (moduleId !== undefined)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        if (exerciseId === null)
            throw new Error("The parameter 'exerciseId' cannot be null.");
        else if (exerciseId !== undefined)
            url_ += "exerciseId=" + encodeURIComponent("" + exerciseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAddExerciseToModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddExerciseToModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsModuleTrainingsExerciseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsModuleTrainingsExerciseDto>;
        }));
    }

    protected processAddExerciseToModule(response: HttpResponseBase): Observable<TrainingsModuleTrainingsExerciseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TrainingsModuleTrainingsExerciseDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleTrainingsExerciseDto>(null as any);
    }

    /**
     * Adds Tag to a specific Module
     * @param moduleId (optional) Id of the needed TrainingsModule
     * @param tagId (optional) the needed Exercise
     * @return TrainingsModuleTrainingsExerciseDto
     */
    addTagToModule(moduleId: number | undefined, tagId: number | undefined): Observable<TrainingsModuleTrainingsExerciseDto> {
        let url_ = this.baseUrl + "/tagmodule?";
        if (moduleId === null)
            throw new Error("The parameter 'moduleId' cannot be null.");
        else if (moduleId !== undefined)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        if (tagId === null)
            throw new Error("The parameter 'tagId' cannot be null.");
        else if (tagId !== undefined)
            url_ += "tagId=" + encodeURIComponent("" + tagId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAddTagToModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTagToModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsModuleTrainingsExerciseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsModuleTrainingsExerciseDto>;
        }));
    }

    protected processAddTagToModule(response: HttpResponseBase): Observable<TrainingsModuleTrainingsExerciseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TrainingsModuleTrainingsExerciseDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleTrainingsExerciseDto>(null as any);
    }

    /**
     * Deletes the TrainingsModuleTag with the given Id from the given Module
     * @param moduleId The TrainingsModuleId (from HTTP-Body)
     * @param tagId The TagId(from HTTP-Body)
     * @return The deleted TrainingsModule
     */
    deleteTagByModuleId(moduleId: number, tagId: number): Observable<TrainingsModuleDto> {
        let url_ = this.baseUrl + "/api/v1/modules/{moduleId}/tags/{tagId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (tagId === undefined || tagId === null)
            throw new Error("The parameter 'tagId' must be defined.");
        url_ = url_.replace("{tagId}", encodeURIComponent("" + tagId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteTagByModuleId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTagByModuleId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsModuleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsModuleDto>;
        }));
    }

    protected processDeleteTagByModuleId(response: HttpResponseBase): Observable<TrainingsModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsModuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleDto>(null as any);
    }

    getAllExercisesByModuleId(id: number): Observable<TrainingsExerciseDto[]> {
        let url_ = this.baseUrl + "/api/v1/modules/{id}/exercises";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllExercisesByModuleId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllExercisesByModuleId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsExerciseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsExerciseDto[]>;
        }));
    }

    protected processGetAllExercisesByModuleId(response: HttpResponseBase): Observable<TrainingsExerciseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsExerciseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsExerciseDto[]>(null as any);
    }

    /**
     * Deletes the Exercise with the given Id from the Module with the given Id
     * @param moduleId The TrainingsModule with updated values (from HTTP-Body)
     * @param exerciseId The TrainingsModule with updated values (from HTTP-Body)
     * @return The deleted TrainingsModule
     */
    deleteExerciseByModuleId(moduleId: number, exerciseId: number): Observable<TrainingsModuleDto> {
        let url_ = this.baseUrl + "/api/v1/modules/{moduleId}/exercises/{exerciseId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (exerciseId === undefined || exerciseId === null)
            throw new Error("The parameter 'exerciseId' must be defined.");
        url_ = url_.replace("{exerciseId}", encodeURIComponent("" + exerciseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteExerciseByModuleId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteExerciseByModuleId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsModuleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsModuleDto>;
        }));
    }

    protected processDeleteExerciseByModuleId(response: HttpResponseBase): Observable<TrainingsModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsModuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleDto>(null as any);
    }

    /**
     * Returns all TrainingsModules
     * @param trainingscModuleId (optional) Id of the needed TrainingsModule
     * @return The TrainingsModule
     */
    getTrainingsModuleById(trainingscModuleId: number | undefined, id: string): Observable<TrainingsModuleDto> {
        let url_ = this.baseUrl + "/api/v1/modules/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (trainingscModuleId === null)
            throw new Error("The parameter 'trainingscModuleId' cannot be null.");
        else if (trainingscModuleId !== undefined)
            url_ += "trainingscModuleId=" + encodeURIComponent("" + trainingscModuleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTrainingsModuleById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrainingsModuleById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsModuleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsModuleDto>;
        }));
    }

    protected processGetTrainingsModuleById(response: HttpResponseBase): Observable<TrainingsModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsModuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleDto>(null as any);
    }

    /**
     * Returns the TrainingsModule with the given Id
     * @return The TrainingsModule
     */
    getTrainingsModulesByUserId(userId: string | null): Observable<TrainingsModuleDto[]> {
        let url_ = this.baseUrl + "/api/v1/modules/byUser/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTrainingsModulesByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrainingsModulesByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsModuleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsModuleDto[]>;
        }));
    }

    protected processGetTrainingsModulesByUserId(response: HttpResponseBase): Observable<TrainingsModuleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsModuleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleDto[]>(null as any);
    }

    /**
     * Returns all TrainingsModules that are part of the given appointment id
     * @param trainingsAppointmentId Id of the needed TrainingsAppointment
     * @return The TrainingsModule
     */
    getTrainingsModulesByAppointmentId(trainingsAppointmentId: number): Observable<TrainingsModuleDto[]> {
        let url_ = this.baseUrl + "/api/v1/modules/appointments/{trainingsAppointmentId}";
        if (trainingsAppointmentId === undefined || trainingsAppointmentId === null)
            throw new Error("The parameter 'trainingsAppointmentId' must be defined.");
        url_ = url_.replace("{trainingsAppointmentId}", encodeURIComponent("" + trainingsAppointmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTrainingsModulesByAppointmentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrainingsModulesByAppointmentId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsModuleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsModuleDto[]>;
        }));
    }

    protected processGetTrainingsModulesByAppointmentId(response: HttpResponseBase): Observable<TrainingsModuleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsModuleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleDto[]>(null as any);
    }

    /**
     * Returns all TrainingsModules
     * @return All TrainingsModules
     */
    getAllPublicTrainingsModules(): Observable<TrainingsModuleDto[]> {
        let url_ = this.baseUrl + "/api/v1/modules/public";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllPublicTrainingsModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPublicTrainingsModules(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsModuleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsModuleDto[]>;
        }));
    }

    protected processGetAllPublicTrainingsModules(response: HttpResponseBase): Observable<TrainingsModuleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsModuleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleDto[]>(null as any);
    }
}

@Injectable()
export class TrainingsModuleTagClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthorizeService) configuration: AuthorizeService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllTags(): Observable<TrainingsModuleTagDto[]> {
        let url_ = this.baseUrl + "/api/v1/tags";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTags(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsModuleTagDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsModuleTagDto[]>;
        }));
    }

    protected processGetAllTags(response: HttpResponseBase): Observable<TrainingsModuleTagDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingsModuleTagDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleTagDto[]>(null as any);
    }

    createTag(trainingsModuleTagDto: TrainingsModuleTagDto): Observable<TrainingsModuleTagDto> {
        let url_ = this.baseUrl + "/api/v1/tags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsModuleTagDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTag(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsModuleTagDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsModuleTagDto>;
        }));
    }

    protected processCreateTag(response: HttpResponseBase): Observable<TrainingsModuleTagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsModuleTagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleTagDto>(null as any);
    }

    updateTag(trainingsModuleTagDto: TrainingsModuleTagDto): Observable<TrainingsModuleTagDto> {
        let url_ = this.baseUrl + "/api/v1/tags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsModuleTagDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTag(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsModuleTagDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsModuleTagDto>;
        }));
    }

    protected processUpdateTag(response: HttpResponseBase): Observable<TrainingsModuleTagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsModuleTagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleTagDto>(null as any);
    }

    deleteTag(trainingsModuleTagDto: TrainingsModuleTagDto): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/tags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trainingsModuleTagDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTag(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteTag(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    getTagById(id: number): Observable<TrainingsModuleTagDto> {
        let url_ = this.baseUrl + "/api/v1/tags/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTagById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTagById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainingsModuleTagDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainingsModuleTagDto>;
        }));
    }

    protected processGetTagById(response: HttpResponseBase): Observable<TrainingsModuleTagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingsModuleTagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingsModuleTagDto>(null as any);
    }
}

@Injectable()
export class UserClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthorizeService) configuration: AuthorizeService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    registerTrainer(model: RegisterViewModel): Observable<ApplicationUser> {
        let url_ = this.baseUrl + "/api/v1/User/api/vi/RegisterTrainer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRegisterTrainer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTrainer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicationUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicationUser>;
        }));
    }

    protected processRegisterTrainer(response: HttpResponseBase): Observable<ApplicationUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUser>(null as any);
    }

    registerAthlete(model: RegisterViewModel): Observable<ApplicationUser> {
        let url_ = this.baseUrl + "/api/v1/User/api/vi/RegisterAthlete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRegisterAthlete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterAthlete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicationUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicationUser>;
        }));
    }

    protected processRegisterAthlete(response: HttpResponseBase): Observable<ApplicationUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUser>(null as any);
    }

    deleteUser(userId: string | null | undefined): Observable<ApplicationUser> {
        let url_ = this.baseUrl + "/api/v1/User/api/vi/DeleteUser?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicationUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicationUser>;
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<ApplicationUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUser>(null as any);
    }

    isAuthenticated(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/v1/User/isAuthenticated";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processIsAuthenticated(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsAuthenticated(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsAuthenticated(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    getUserById(userId: string | null): Observable<ApplicationUser> {
        let url_ = this.baseUrl + "/api/v1/User/byId/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetUserById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicationUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicationUser>;
        }));
    }

    protected processGetUserById(response: HttpResponseBase): Observable<ApplicationUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUser>(null as any);
    }

    getUserByName(name: string | null): Observable<ApplicationUser> {
        let url_ = this.baseUrl + "/api/v1/User/byName/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetUserByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicationUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicationUser>;
        }));
    }

    protected processGetUserByName(response: HttpResponseBase): Observable<ApplicationUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUser>(null as any);
    }

    getTrainers(): Observable<ApplicationUser[]> {
        let url_ = this.baseUrl + "/api/v1/User/api/vi/GetTrainers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTrainers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrainers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicationUser[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicationUser[]>;
        }));
    }

    protected processGetTrainers(response: HttpResponseBase): Observable<ApplicationUser[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ApplicationUser.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUser[]>(null as any);
    }

    getUserByEmail(email: string | null): Observable<ApplicationUser> {
        let url_ = this.baseUrl + "/api/v1/User/byEmail/{email}";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetUserByEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserByEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicationUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicationUser>;
        }));
    }

    protected processGetUserByEmail(response: HttpResponseBase): Observable<ApplicationUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUser>(null as any);
    }

    allowReadGroup(trainignsGroupId: number | undefined, userId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/User/api/vi/AllowReadGroup?";
        if (trainignsGroupId === null)
            throw new Error("The parameter 'trainignsGroupId' cannot be null.");
        else if (trainignsGroupId !== undefined)
            url_ += "trainignsGroupId=" + encodeURIComponent("" + trainignsGroupId) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAllowReadGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllowReadGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAllowReadGroup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    allowEditGroup(trainignsGroupId: number | undefined, userId: string | null | undefined): Observable<ApplicationUser> {
        let url_ = this.baseUrl + "/api/v1/User/api/vi/AllowEditGroup?";
        if (trainignsGroupId === null)
            throw new Error("The parameter 'trainignsGroupId' cannot be null.");
        else if (trainignsGroupId !== undefined)
            url_ += "trainignsGroupId=" + encodeURIComponent("" + trainignsGroupId) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAllowEditGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllowEditGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicationUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicationUser>;
        }));
    }

    protected processAllowEditGroup(response: HttpResponseBase): Observable<ApplicationUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUser>(null as any);
    }

    allowEditAppointment(trainingsAppointmentId: number | undefined, groupId: number | undefined): Observable<ApplicationUser> {
        let url_ = this.baseUrl + "/api/v1/User/api/vi/AllowEditAppointment?";
        if (trainingsAppointmentId === null)
            throw new Error("The parameter 'trainingsAppointmentId' cannot be null.");
        else if (trainingsAppointmentId !== undefined)
            url_ += "trainingsAppointmentId=" + encodeURIComponent("" + trainingsAppointmentId) + "&";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAllowEditAppointment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllowEditAppointment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicationUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicationUser>;
        }));
    }

    protected processAllowEditAppointment(response: HttpResponseBase): Observable<ApplicationUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUser>(null as any);
    }

    allowEditModule(trainingsModuleId: number | undefined, userId: string | null | undefined): Observable<ApplicationUser> {
        let url_ = this.baseUrl + "/api/v1/User/api/vi/AllowEditModule?";
        if (trainingsModuleId === null)
            throw new Error("The parameter 'trainingsModuleId' cannot be null.");
        else if (trainingsModuleId !== undefined)
            url_ += "trainingsModuleId=" + encodeURIComponent("" + trainingsModuleId) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAllowEditModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllowEditModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicationUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicationUser>;
        }));
    }

    protected processAllowEditModule(response: HttpResponseBase): Observable<ApplicationUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUser>(null as any);
    }

    disallowEditModule(moduleId: number | undefined, userId: string | null | undefined): Observable<ApplicationUser> {
        let url_ = this.baseUrl + "/api/v1/User/api/vi/DisallowEditModule?";
        if (moduleId === null)
            throw new Error("The parameter 'moduleId' cannot be null.");
        else if (moduleId !== undefined)
            url_ += "moduleId=" + encodeURIComponent("" + moduleId) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDisallowEditModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisallowEditModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicationUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicationUser>;
        }));
    }

    protected processDisallowEditModule(response: HttpResponseBase): Observable<ApplicationUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUser>(null as any);
    }

    disallowEditAppointment(appointmentId: number | undefined, groupId: number | undefined): Observable<ApplicationUser> {
        let url_ = this.baseUrl + "/api/v1/User/api/vi/DisallowEditAppointment?";
        if (appointmentId === null)
            throw new Error("The parameter 'appointmentId' cannot be null.");
        else if (appointmentId !== undefined)
            url_ += "appointmentId=" + encodeURIComponent("" + appointmentId) + "&";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDisallowEditAppointment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisallowEditAppointment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicationUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicationUser>;
        }));
    }

    protected processDisallowEditAppointment(response: HttpResponseBase): Observable<ApplicationUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUser>(null as any);
    }

    disallowEditGroup(groupId: number | undefined, userId: string | null | undefined): Observable<ApplicationUser> {
        let url_ = this.baseUrl + "/api/v1/User/api/vi/DisallowEditGroup?";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDisallowEditGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisallowEditGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicationUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicationUser>;
        }));
    }

    protected processDisallowEditGroup(response: HttpResponseBase): Observable<ApplicationUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUser>(null as any);
    }

    disallowReadGroup(groupId: number | undefined, userId: string | null | undefined): Observable<ApplicationUser> {
        let url_ = this.baseUrl + "/api/v1/User/api/vi/DisallowReadGroup?";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDisallowReadGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisallowReadGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicationUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicationUser>;
        }));
    }

    protected processDisallowReadGroup(response: HttpResponseBase): Observable<ApplicationUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUser>(null as any);
    }
}

@Injectable()
export class WeatherForecastClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthorizeService) configuration: AuthorizeService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherForecast[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherForecast[]>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeatherForecast[]>(null as any);
    }
}

export class TrainingsModuleFollowDto implements ITrainingsModuleFollowDto {
    id?: number;
    trainingsModuleId?: number;
    trainingsModule?: TrainingsModuleDto | undefined;
    userId?: string | undefined;
    user?: ApplicationUser | undefined;
    created?: Date;
    updatet?: Date | undefined;

    constructor(data?: ITrainingsModuleFollowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.trainingsModuleId = _data["trainingsModuleId"];
            this.trainingsModule = _data["trainingsModule"] ? TrainingsModuleDto.fromJS(_data["trainingsModule"]) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updatet = _data["updatet"] ? new Date(_data["updatet"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsModuleFollowDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsModuleFollowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["trainingsModuleId"] = this.trainingsModuleId;
        data["trainingsModule"] = this.trainingsModule ? this.trainingsModule.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updatet"] = this.updatet ? this.updatet.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITrainingsModuleFollowDto {
    id?: number;
    trainingsModuleId?: number;
    trainingsModule?: TrainingsModuleDto | undefined;
    userId?: string | undefined;
    user?: ApplicationUser | undefined;
    created?: Date;
    updatet?: Date | undefined;
}

export class TrainingsModuleDto implements ITrainingsModuleDto {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    isPublic?: boolean;
    isFollowed?: boolean;
    difficulty?: TrainingsDifficulty;
    userId?: string | undefined;
    user?: ApplicationUser | undefined;
    trainingsModulesTrainingsExercises?: TrainingsModuleTrainingsExercise[] | undefined;
    trainingsModulesTrainingsModuleTags?: TrainingsModuleTrainingsModuleTag[] | undefined;
    trainingsAppointmentsTrainingsModules?: TrainingsAppointmentTrainingsModule[] | undefined;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsModuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.isPublic = _data["isPublic"];
            this.isFollowed = _data["isFollowed"];
            this.difficulty = _data["difficulty"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["trainingsModulesTrainingsExercises"])) {
                this.trainingsModulesTrainingsExercises = [] as any;
                for (let item of _data["trainingsModulesTrainingsExercises"])
                    this.trainingsModulesTrainingsExercises!.push(TrainingsModuleTrainingsExercise.fromJS(item));
            }
            if (Array.isArray(_data["trainingsModulesTrainingsModuleTags"])) {
                this.trainingsModulesTrainingsModuleTags = [] as any;
                for (let item of _data["trainingsModulesTrainingsModuleTags"])
                    this.trainingsModulesTrainingsModuleTags!.push(TrainingsModuleTrainingsModuleTag.fromJS(item));
            }
            if (Array.isArray(_data["trainingsAppointmentsTrainingsModules"])) {
                this.trainingsAppointmentsTrainingsModules = [] as any;
                for (let item of _data["trainingsAppointmentsTrainingsModules"])
                    this.trainingsAppointmentsTrainingsModules!.push(TrainingsAppointmentTrainingsModule.fromJS(item));
            }
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsModuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsModuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["isPublic"] = this.isPublic;
        data["isFollowed"] = this.isFollowed;
        data["difficulty"] = this.difficulty;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.trainingsModulesTrainingsExercises)) {
            data["trainingsModulesTrainingsExercises"] = [];
            for (let item of this.trainingsModulesTrainingsExercises)
                data["trainingsModulesTrainingsExercises"].push(item.toJSON());
        }
        if (Array.isArray(this.trainingsModulesTrainingsModuleTags)) {
            data["trainingsModulesTrainingsModuleTags"] = [];
            for (let item of this.trainingsModulesTrainingsModuleTags)
                data["trainingsModulesTrainingsModuleTags"].push(item.toJSON());
        }
        if (Array.isArray(this.trainingsAppointmentsTrainingsModules)) {
            data["trainingsAppointmentsTrainingsModules"] = [];
            for (let item of this.trainingsAppointmentsTrainingsModules)
                data["trainingsAppointmentsTrainingsModules"].push(item.toJSON());
        }
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITrainingsModuleDto {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    isPublic?: boolean;
    isFollowed?: boolean;
    difficulty?: TrainingsDifficulty;
    userId?: string | undefined;
    user?: ApplicationUser | undefined;
    trainingsModulesTrainingsExercises?: TrainingsModuleTrainingsExercise[] | undefined;
    trainingsModulesTrainingsModuleTags?: TrainingsModuleTrainingsModuleTag[] | undefined;
    trainingsAppointmentsTrainingsModules?: TrainingsAppointmentTrainingsModule[] | undefined;
    created?: Date;
    updated?: Date | undefined;
}

export enum TrainingsDifficulty {
    UNKNOWN = 0,
    EASY = 10,
    MEDIUM = 20,
    HARD = 30,
    IMPOSSIBLE = 40,
}

export class IdentityUserOfString implements IIdentityUserOfString {
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;

    constructor(data?: IIdentityUserOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
        }
    }

    static fromJS(data: any): IdentityUserOfString {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        return data;
    }
}

export interface IIdentityUserOfString {
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
}

export class IdentityUser extends IdentityUserOfString implements IIdentityUser {

    constructor(data?: IIdentityUser) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): IdentityUser {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IIdentityUser extends IIdentityUserOfString {
}

export class ApplicationUser extends IdentityUser implements IApplicationUser {
    lastName?: string | undefined;
    firstName?: string | undefined;
    follows?: TrainingsModuleFollow[] | undefined;

    constructor(data?: IApplicationUser) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.lastName = _data["lastName"];
            this.firstName = _data["firstName"];
            if (Array.isArray(_data["follows"])) {
                this.follows = [] as any;
                for (let item of _data["follows"])
                    this.follows!.push(TrainingsModuleFollow.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lastName"] = this.lastName;
        data["firstName"] = this.firstName;
        if (Array.isArray(this.follows)) {
            data["follows"] = [];
            for (let item of this.follows)
                data["follows"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IApplicationUser extends IIdentityUser {
    lastName?: string | undefined;
    firstName?: string | undefined;
    follows?: TrainingsModuleFollow[] | undefined;
}

export class TrainingsModuleFollow implements ITrainingsModuleFollow {
    trainingsModuleId?: number;
    trainingsModule?: TrainingsModule | undefined;
    userId?: string | undefined;
    user?: ApplicationUser | undefined;
    created?: Date;

    constructor(data?: ITrainingsModuleFollow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingsModuleId = _data["trainingsModuleId"];
            this.trainingsModule = _data["trainingsModule"] ? TrainingsModule.fromJS(_data["trainingsModule"]) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsModuleFollow {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsModuleFollow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingsModuleId"] = this.trainingsModuleId;
        data["trainingsModule"] = this.trainingsModule ? this.trainingsModule.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITrainingsModuleFollow {
    trainingsModuleId?: number;
    trainingsModule?: TrainingsModule | undefined;
    userId?: string | undefined;
    user?: ApplicationUser | undefined;
    created?: Date;
}

export class TrainingsModule implements ITrainingsModule {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    isPublic?: boolean;
    difficulty?: TrainingsDifficulty;
    userId?: string | undefined;
    user?: ApplicationUser | undefined;
    trainingsModulesTrainingsExercises?: TrainingsModuleTrainingsExercise[] | undefined;
    trainingsModulesTrainingsModuleTags?: TrainingsModuleTrainingsModuleTag[] | undefined;
    trainingsAppointmentsTrainingsModules?: TrainingsAppointmentTrainingsModule[] | undefined;
    followers?: TrainingsModuleFollow[] | undefined;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.isPublic = _data["isPublic"];
            this.difficulty = _data["difficulty"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["trainingsModulesTrainingsExercises"])) {
                this.trainingsModulesTrainingsExercises = [] as any;
                for (let item of _data["trainingsModulesTrainingsExercises"])
                    this.trainingsModulesTrainingsExercises!.push(TrainingsModuleTrainingsExercise.fromJS(item));
            }
            if (Array.isArray(_data["trainingsModulesTrainingsModuleTags"])) {
                this.trainingsModulesTrainingsModuleTags = [] as any;
                for (let item of _data["trainingsModulesTrainingsModuleTags"])
                    this.trainingsModulesTrainingsModuleTags!.push(TrainingsModuleTrainingsModuleTag.fromJS(item));
            }
            if (Array.isArray(_data["trainingsAppointmentsTrainingsModules"])) {
                this.trainingsAppointmentsTrainingsModules = [] as any;
                for (let item of _data["trainingsAppointmentsTrainingsModules"])
                    this.trainingsAppointmentsTrainingsModules!.push(TrainingsAppointmentTrainingsModule.fromJS(item));
            }
            if (Array.isArray(_data["followers"])) {
                this.followers = [] as any;
                for (let item of _data["followers"])
                    this.followers!.push(TrainingsModuleFollow.fromJS(item));
            }
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsModule {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsModule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["isPublic"] = this.isPublic;
        data["difficulty"] = this.difficulty;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.trainingsModulesTrainingsExercises)) {
            data["trainingsModulesTrainingsExercises"] = [];
            for (let item of this.trainingsModulesTrainingsExercises)
                data["trainingsModulesTrainingsExercises"].push(item.toJSON());
        }
        if (Array.isArray(this.trainingsModulesTrainingsModuleTags)) {
            data["trainingsModulesTrainingsModuleTags"] = [];
            for (let item of this.trainingsModulesTrainingsModuleTags)
                data["trainingsModulesTrainingsModuleTags"].push(item.toJSON());
        }
        if (Array.isArray(this.trainingsAppointmentsTrainingsModules)) {
            data["trainingsAppointmentsTrainingsModules"] = [];
            for (let item of this.trainingsAppointmentsTrainingsModules)
                data["trainingsAppointmentsTrainingsModules"].push(item.toJSON());
        }
        if (Array.isArray(this.followers)) {
            data["followers"] = [];
            for (let item of this.followers)
                data["followers"].push(item.toJSON());
        }
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITrainingsModule {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    isPublic?: boolean;
    difficulty?: TrainingsDifficulty;
    userId?: string | undefined;
    user?: ApplicationUser | undefined;
    trainingsModulesTrainingsExercises?: TrainingsModuleTrainingsExercise[] | undefined;
    trainingsModulesTrainingsModuleTags?: TrainingsModuleTrainingsModuleTag[] | undefined;
    trainingsAppointmentsTrainingsModules?: TrainingsAppointmentTrainingsModule[] | undefined;
    followers?: TrainingsModuleFollow[] | undefined;
    created?: Date;
    updated?: Date | undefined;
}

export class TrainingsModuleTrainingsExercise implements ITrainingsModuleTrainingsExercise {
    trainingsModuleId?: number;
    trainingsModule?: TrainingsModule | undefined;
    trainingsExerciesId?: number;
    trainingsExercise?: TrainingsExercise | undefined;
    position?: number;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsModuleTrainingsExercise) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingsModuleId = _data["trainingsModuleId"];
            this.trainingsModule = _data["trainingsModule"] ? TrainingsModule.fromJS(_data["trainingsModule"]) : <any>undefined;
            this.trainingsExerciesId = _data["trainingsExerciesId"];
            this.trainingsExercise = _data["trainingsExercise"] ? TrainingsExercise.fromJS(_data["trainingsExercise"]) : <any>undefined;
            this.position = _data["position"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsModuleTrainingsExercise {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsModuleTrainingsExercise();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingsModuleId"] = this.trainingsModuleId;
        data["trainingsModule"] = this.trainingsModule ? this.trainingsModule.toJSON() : <any>undefined;
        data["trainingsExerciesId"] = this.trainingsExerciesId;
        data["trainingsExercise"] = this.trainingsExercise ? this.trainingsExercise.toJSON() : <any>undefined;
        data["position"] = this.position;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITrainingsModuleTrainingsExercise {
    trainingsModuleId?: number;
    trainingsModule?: TrainingsModule | undefined;
    trainingsExerciesId?: number;
    trainingsExercise?: TrainingsExercise | undefined;
    position?: number;
    created?: Date;
    updated?: Date | undefined;
}

export class TrainingsExercise implements ITrainingsExercise {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    duration?: number;
    repetitions?: number;
    trainingsModulesTrainingsExercises?: TrainingsModuleTrainingsExercise[] | undefined;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsExercise) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.duration = _data["duration"];
            this.repetitions = _data["repetitions"];
            if (Array.isArray(_data["trainingsModulesTrainingsExercises"])) {
                this.trainingsModulesTrainingsExercises = [] as any;
                for (let item of _data["trainingsModulesTrainingsExercises"])
                    this.trainingsModulesTrainingsExercises!.push(TrainingsModuleTrainingsExercise.fromJS(item));
            }
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsExercise {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsExercise();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["duration"] = this.duration;
        data["repetitions"] = this.repetitions;
        if (Array.isArray(this.trainingsModulesTrainingsExercises)) {
            data["trainingsModulesTrainingsExercises"] = [];
            for (let item of this.trainingsModulesTrainingsExercises)
                data["trainingsModulesTrainingsExercises"].push(item.toJSON());
        }
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITrainingsExercise {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    duration?: number;
    repetitions?: number;
    trainingsModulesTrainingsExercises?: TrainingsModuleTrainingsExercise[] | undefined;
    created?: Date;
    updated?: Date | undefined;
}

export class TrainingsModuleTrainingsModuleTag implements ITrainingsModuleTrainingsModuleTag {
    trainingsModuleId?: number;
    trainingsModule?: TrainingsModule | undefined;
    trainingsModuleTagId?: number;
    trainingsModuleTag?: TrainingsModuleTag | undefined;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsModuleTrainingsModuleTag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingsModuleId = _data["trainingsModuleId"];
            this.trainingsModule = _data["trainingsModule"] ? TrainingsModule.fromJS(_data["trainingsModule"]) : <any>undefined;
            this.trainingsModuleTagId = _data["trainingsModuleTagId"];
            this.trainingsModuleTag = _data["trainingsModuleTag"] ? TrainingsModuleTag.fromJS(_data["trainingsModuleTag"]) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsModuleTrainingsModuleTag {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsModuleTrainingsModuleTag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingsModuleId"] = this.trainingsModuleId;
        data["trainingsModule"] = this.trainingsModule ? this.trainingsModule.toJSON() : <any>undefined;
        data["trainingsModuleTagId"] = this.trainingsModuleTagId;
        data["trainingsModuleTag"] = this.trainingsModuleTag ? this.trainingsModuleTag.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITrainingsModuleTrainingsModuleTag {
    trainingsModuleId?: number;
    trainingsModule?: TrainingsModule | undefined;
    trainingsModuleTagId?: number;
    trainingsModuleTag?: TrainingsModuleTag | undefined;
    created?: Date;
    updated?: Date | undefined;
}

export class TrainingsModuleTag implements ITrainingsModuleTag {
    id?: number;
    title?: string | undefined;
    trainingsModulesTrainingsModuleTags?: TrainingsModuleTrainingsModuleTag[] | undefined;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsModuleTag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            if (Array.isArray(_data["trainingsModulesTrainingsModuleTags"])) {
                this.trainingsModulesTrainingsModuleTags = [] as any;
                for (let item of _data["trainingsModulesTrainingsModuleTags"])
                    this.trainingsModulesTrainingsModuleTags!.push(TrainingsModuleTrainingsModuleTag.fromJS(item));
            }
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsModuleTag {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsModuleTag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        if (Array.isArray(this.trainingsModulesTrainingsModuleTags)) {
            data["trainingsModulesTrainingsModuleTags"] = [];
            for (let item of this.trainingsModulesTrainingsModuleTags)
                data["trainingsModulesTrainingsModuleTags"].push(item.toJSON());
        }
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITrainingsModuleTag {
    id?: number;
    title?: string | undefined;
    trainingsModulesTrainingsModuleTags?: TrainingsModuleTrainingsModuleTag[] | undefined;
    created?: Date;
    updated?: Date | undefined;
}

export class TrainingsAppointmentTrainingsModule implements ITrainingsAppointmentTrainingsModule {
    trainingsModuleId?: number;
    trainingsModule?: TrainingsModule | undefined;
    trainingsAppointmentId?: number;
    trainingsAppointment?: TrainingsAppointment | undefined;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsAppointmentTrainingsModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingsModuleId = _data["trainingsModuleId"];
            this.trainingsModule = _data["trainingsModule"] ? TrainingsModule.fromJS(_data["trainingsModule"]) : <any>undefined;
            this.trainingsAppointmentId = _data["trainingsAppointmentId"];
            this.trainingsAppointment = _data["trainingsAppointment"] ? TrainingsAppointment.fromJS(_data["trainingsAppointment"]) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsAppointmentTrainingsModule {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsAppointmentTrainingsModule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingsModuleId"] = this.trainingsModuleId;
        data["trainingsModule"] = this.trainingsModule ? this.trainingsModule.toJSON() : <any>undefined;
        data["trainingsAppointmentId"] = this.trainingsAppointmentId;
        data["trainingsAppointment"] = this.trainingsAppointment ? this.trainingsAppointment.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITrainingsAppointmentTrainingsModule {
    trainingsModuleId?: number;
    trainingsModule?: TrainingsModule | undefined;
    trainingsAppointmentId?: number;
    trainingsAppointment?: TrainingsAppointment | undefined;
    created?: Date;
    updated?: Date | undefined;
}

export class TrainingsAppointment implements ITrainingsAppointment {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    userId?: string | undefined;
    endTime?: Date;
    startTime?: Date;
    trainingsGroupId?: number;
    trainingsGroup?: TrainingsGroup | undefined;
    trainingsAppointmentsTrainingsModules?: TrainingsAppointmentTrainingsModule[] | undefined;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsAppointment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.userId = _data["userId"];
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.trainingsGroupId = _data["trainingsGroupId"];
            this.trainingsGroup = _data["trainingsGroup"] ? TrainingsGroup.fromJS(_data["trainingsGroup"]) : <any>undefined;
            if (Array.isArray(_data["trainingsAppointmentsTrainingsModules"])) {
                this.trainingsAppointmentsTrainingsModules = [] as any;
                for (let item of _data["trainingsAppointmentsTrainingsModules"])
                    this.trainingsAppointmentsTrainingsModules!.push(TrainingsAppointmentTrainingsModule.fromJS(item));
            }
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsAppointment {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsAppointment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["userId"] = this.userId;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["trainingsGroupId"] = this.trainingsGroupId;
        data["trainingsGroup"] = this.trainingsGroup ? this.trainingsGroup.toJSON() : <any>undefined;
        if (Array.isArray(this.trainingsAppointmentsTrainingsModules)) {
            data["trainingsAppointmentsTrainingsModules"] = [];
            for (let item of this.trainingsAppointmentsTrainingsModules)
                data["trainingsAppointmentsTrainingsModules"].push(item.toJSON());
        }
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITrainingsAppointment {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    userId?: string | undefined;
    endTime?: Date;
    startTime?: Date;
    trainingsGroupId?: number;
    trainingsGroup?: TrainingsGroup | undefined;
    trainingsAppointmentsTrainingsModules?: TrainingsAppointmentTrainingsModule[] | undefined;
    created?: Date;
    updated?: Date | undefined;
}

export class TrainingsGroup implements ITrainingsGroup {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    trainingsGroupsApplicationUsers?: TrainingsGroupApplicationUser[] | undefined;
    trainingsAppointments?: TrainingsAppointment[] | undefined;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            if (Array.isArray(_data["trainingsGroupsApplicationUsers"])) {
                this.trainingsGroupsApplicationUsers = [] as any;
                for (let item of _data["trainingsGroupsApplicationUsers"])
                    this.trainingsGroupsApplicationUsers!.push(TrainingsGroupApplicationUser.fromJS(item));
            }
            if (Array.isArray(_data["trainingsAppointments"])) {
                this.trainingsAppointments = [] as any;
                for (let item of _data["trainingsAppointments"])
                    this.trainingsAppointments!.push(TrainingsAppointment.fromJS(item));
            }
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsGroup {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        if (Array.isArray(this.trainingsGroupsApplicationUsers)) {
            data["trainingsGroupsApplicationUsers"] = [];
            for (let item of this.trainingsGroupsApplicationUsers)
                data["trainingsGroupsApplicationUsers"].push(item.toJSON());
        }
        if (Array.isArray(this.trainingsAppointments)) {
            data["trainingsAppointments"] = [];
            for (let item of this.trainingsAppointments)
                data["trainingsAppointments"].push(item.toJSON());
        }
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITrainingsGroup {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    trainingsGroupsApplicationUsers?: TrainingsGroupApplicationUser[] | undefined;
    trainingsAppointments?: TrainingsAppointment[] | undefined;
    created?: Date;
    updated?: Date | undefined;
}

export class TrainingsGroupApplicationUser implements ITrainingsGroupApplicationUser {
    trainingsGroupId?: number;
    trainingsGroup?: TrainingsGroup | undefined;
    applicationUserId?: string | undefined;
    isTrainer?: boolean;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsGroupApplicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingsGroupId = _data["trainingsGroupId"];
            this.trainingsGroup = _data["trainingsGroup"] ? TrainingsGroup.fromJS(_data["trainingsGroup"]) : <any>undefined;
            this.applicationUserId = _data["applicationUserId"];
            this.isTrainer = _data["isTrainer"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsGroupApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsGroupApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingsGroupId"] = this.trainingsGroupId;
        data["trainingsGroup"] = this.trainingsGroup ? this.trainingsGroup.toJSON() : <any>undefined;
        data["applicationUserId"] = this.applicationUserId;
        data["isTrainer"] = this.isTrainer;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITrainingsGroupApplicationUser {
    trainingsGroupId?: number;
    trainingsGroup?: TrainingsGroup | undefined;
    applicationUserId?: string | undefined;
    isTrainer?: boolean;
    created?: Date;
    updated?: Date | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; };

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["extensions"]) {
                this.extensions = {} as any;
                for (let key in _data["extensions"]) {
                    if (_data["extensions"].hasOwnProperty(key))
                        (<any>this.extensions)![key] = _data["extensions"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.extensions) {
            data["extensions"] = {};
            for (let key in this.extensions) {
                if (this.extensions.hasOwnProperty(key))
                    (<any>data["extensions"])[key] = this.extensions[key];
            }
        }
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; };
}

export class TrainingsAppointmentDto implements ITrainingsAppointmentDto {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    userId?: string | undefined;
    endTime?: Date;
    startTime?: Date;
    trainingsGroupId?: number;
    trainingsGroup?: TrainingsGroup | undefined;
    trainingsAppointmentsTrainingsModules?: TrainingsAppointmentTrainingsModule[] | undefined;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsAppointmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.userId = _data["userId"];
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.trainingsGroupId = _data["trainingsGroupId"];
            this.trainingsGroup = _data["trainingsGroup"] ? TrainingsGroup.fromJS(_data["trainingsGroup"]) : <any>undefined;
            if (Array.isArray(_data["trainingsAppointmentsTrainingsModules"])) {
                this.trainingsAppointmentsTrainingsModules = [] as any;
                for (let item of _data["trainingsAppointmentsTrainingsModules"])
                    this.trainingsAppointmentsTrainingsModules!.push(TrainingsAppointmentTrainingsModule.fromJS(item));
            }
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsAppointmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsAppointmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["userId"] = this.userId;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["trainingsGroupId"] = this.trainingsGroupId;
        data["trainingsGroup"] = this.trainingsGroup ? this.trainingsGroup.toJSON() : <any>undefined;
        if (Array.isArray(this.trainingsAppointmentsTrainingsModules)) {
            data["trainingsAppointmentsTrainingsModules"] = [];
            for (let item of this.trainingsAppointmentsTrainingsModules)
                data["trainingsAppointmentsTrainingsModules"].push(item.toJSON());
        }
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITrainingsAppointmentDto {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    userId?: string | undefined;
    endTime?: Date;
    startTime?: Date;
    trainingsGroupId?: number;
    trainingsGroup?: TrainingsGroup | undefined;
    trainingsAppointmentsTrainingsModules?: TrainingsAppointmentTrainingsModule[] | undefined;
    created?: Date;
    updated?: Date | undefined;
}

export class TrainingsAppointmentTrainingsModuleDto implements ITrainingsAppointmentTrainingsModuleDto {
    trainingsModuleId?: number;
    trainingsModule?: TrainingsModule | undefined;
    trainingsAppointmentId?: number;
    trainingsAppointment?: TrainingsAppointment | undefined;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsAppointmentTrainingsModuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingsModuleId = _data["trainingsModuleId"];
            this.trainingsModule = _data["trainingsModule"] ? TrainingsModule.fromJS(_data["trainingsModule"]) : <any>undefined;
            this.trainingsAppointmentId = _data["trainingsAppointmentId"];
            this.trainingsAppointment = _data["trainingsAppointment"] ? TrainingsAppointment.fromJS(_data["trainingsAppointment"]) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsAppointmentTrainingsModuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsAppointmentTrainingsModuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingsModuleId"] = this.trainingsModuleId;
        data["trainingsModule"] = this.trainingsModule ? this.trainingsModule.toJSON() : <any>undefined;
        data["trainingsAppointmentId"] = this.trainingsAppointmentId;
        data["trainingsAppointment"] = this.trainingsAppointment ? this.trainingsAppointment.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITrainingsAppointmentTrainingsModuleDto {
    trainingsModuleId?: number;
    trainingsModule?: TrainingsModule | undefined;
    trainingsAppointmentId?: number;
    trainingsAppointment?: TrainingsAppointment | undefined;
    created?: Date;
    updated?: Date | undefined;
}

export class TrainingsExerciseDto implements ITrainingsExerciseDto {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    duration?: number;
    repetitions?: number;
    trainingsModulesTrainingsExercises?: TrainingsModuleTrainingsExercise[] | undefined;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsExerciseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.duration = _data["duration"];
            this.repetitions = _data["repetitions"];
            if (Array.isArray(_data["trainingsModulesTrainingsExercises"])) {
                this.trainingsModulesTrainingsExercises = [] as any;
                for (let item of _data["trainingsModulesTrainingsExercises"])
                    this.trainingsModulesTrainingsExercises!.push(TrainingsModuleTrainingsExercise.fromJS(item));
            }
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsExerciseDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsExerciseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["duration"] = this.duration;
        data["repetitions"] = this.repetitions;
        if (Array.isArray(this.trainingsModulesTrainingsExercises)) {
            data["trainingsModulesTrainingsExercises"] = [];
            for (let item of this.trainingsModulesTrainingsExercises)
                data["trainingsModulesTrainingsExercises"].push(item.toJSON());
        }
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITrainingsExerciseDto {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    duration?: number;
    repetitions?: number;
    trainingsModulesTrainingsExercises?: TrainingsModuleTrainingsExercise[] | undefined;
    created?: Date;
    updated?: Date | undefined;
}

export class TrainingsGroupDto implements ITrainingsGroupDto {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    trainingsGroupsApplicationUsers?: TrainingsGroupApplicationUser[] | undefined;
    trainingsAppointments?: TrainingsAppointment[] | undefined;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            if (Array.isArray(_data["trainingsGroupsApplicationUsers"])) {
                this.trainingsGroupsApplicationUsers = [] as any;
                for (let item of _data["trainingsGroupsApplicationUsers"])
                    this.trainingsGroupsApplicationUsers!.push(TrainingsGroupApplicationUser.fromJS(item));
            }
            if (Array.isArray(_data["trainingsAppointments"])) {
                this.trainingsAppointments = [] as any;
                for (let item of _data["trainingsAppointments"])
                    this.trainingsAppointments!.push(TrainingsAppointment.fromJS(item));
            }
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        if (Array.isArray(this.trainingsGroupsApplicationUsers)) {
            data["trainingsGroupsApplicationUsers"] = [];
            for (let item of this.trainingsGroupsApplicationUsers)
                data["trainingsGroupsApplicationUsers"].push(item.toJSON());
        }
        if (Array.isArray(this.trainingsAppointments)) {
            data["trainingsAppointments"] = [];
            for (let item of this.trainingsAppointments)
                data["trainingsAppointments"].push(item.toJSON());
        }
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITrainingsGroupDto {
    id?: number;
    title?: string | undefined;
    description?: string | undefined;
    trainingsGroupsApplicationUsers?: TrainingsGroupApplicationUser[] | undefined;
    trainingsAppointments?: TrainingsAppointment[] | undefined;
    created?: Date;
    updated?: Date | undefined;
}

export class TrainingsGroupApplicationUserDto implements ITrainingsGroupApplicationUserDto {
    trainingsGroupId?: number;
    trainingsGroup?: TrainingsGroup | undefined;
    applicationUserId?: string | undefined;
    isTrainer?: boolean;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsGroupApplicationUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingsGroupId = _data["trainingsGroupId"];
            this.trainingsGroup = _data["trainingsGroup"] ? TrainingsGroup.fromJS(_data["trainingsGroup"]) : <any>undefined;
            this.applicationUserId = _data["applicationUserId"];
            this.isTrainer = _data["isTrainer"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsGroupApplicationUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsGroupApplicationUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingsGroupId"] = this.trainingsGroupId;
        data["trainingsGroup"] = this.trainingsGroup ? this.trainingsGroup.toJSON() : <any>undefined;
        data["applicationUserId"] = this.applicationUserId;
        data["isTrainer"] = this.isTrainer;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITrainingsGroupApplicationUserDto {
    trainingsGroupId?: number;
    trainingsGroup?: TrainingsGroup | undefined;
    applicationUserId?: string | undefined;
    isTrainer?: boolean;
    created?: Date;
    updated?: Date | undefined;
}

export class TrainingsModuleTrainingsExerciseDto implements ITrainingsModuleTrainingsExerciseDto {
    trainingsModuleId?: number;
    trainingsModule?: TrainingsModule | undefined;
    trainingsExerciesId?: number;
    trainingsExercise?: TrainingsExercise | undefined;
    position?: number;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsModuleTrainingsExerciseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingsModuleId = _data["trainingsModuleId"];
            this.trainingsModule = _data["trainingsModule"] ? TrainingsModule.fromJS(_data["trainingsModule"]) : <any>undefined;
            this.trainingsExerciesId = _data["trainingsExerciesId"];
            this.trainingsExercise = _data["trainingsExercise"] ? TrainingsExercise.fromJS(_data["trainingsExercise"]) : <any>undefined;
            this.position = _data["position"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsModuleTrainingsExerciseDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsModuleTrainingsExerciseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingsModuleId"] = this.trainingsModuleId;
        data["trainingsModule"] = this.trainingsModule ? this.trainingsModule.toJSON() : <any>undefined;
        data["trainingsExerciesId"] = this.trainingsExerciesId;
        data["trainingsExercise"] = this.trainingsExercise ? this.trainingsExercise.toJSON() : <any>undefined;
        data["position"] = this.position;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITrainingsModuleTrainingsExerciseDto {
    trainingsModuleId?: number;
    trainingsModule?: TrainingsModule | undefined;
    trainingsExerciesId?: number;
    trainingsExercise?: TrainingsExercise | undefined;
    position?: number;
    created?: Date;
    updated?: Date | undefined;
}

export class TrainingsModuleTagDto implements ITrainingsModuleTagDto {
    id?: number;
    title?: string | undefined;
    trainingsModulesTrainingsModuleTags?: TrainingsModuleTrainingsModuleTag[] | undefined;
    created?: Date;
    updated?: Date | undefined;

    constructor(data?: ITrainingsModuleTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            if (Array.isArray(_data["trainingsModulesTrainingsModuleTags"])) {
                this.trainingsModulesTrainingsModuleTags = [] as any;
                for (let item of _data["trainingsModulesTrainingsModuleTags"])
                    this.trainingsModulesTrainingsModuleTags!.push(TrainingsModuleTrainingsModuleTag.fromJS(item));
            }
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingsModuleTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingsModuleTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        if (Array.isArray(this.trainingsModulesTrainingsModuleTags)) {
            data["trainingsModulesTrainingsModuleTags"] = [];
            for (let item of this.trainingsModulesTrainingsModuleTags)
                data["trainingsModulesTrainingsModuleTags"].push(item.toJSON());
        }
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITrainingsModuleTagDto {
    id?: number;
    title?: string | undefined;
    trainingsModulesTrainingsModuleTags?: TrainingsModuleTrainingsModuleTag[] | undefined;
    created?: Date;
    updated?: Date | undefined;
}

export class RegisterViewModel implements IRegisterViewModel {
    firstname!: string;
    lastname!: string;
    password?: string | undefined;
    email!: string;
    isTrainer?: boolean;

    constructor(data?: IRegisterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstname = _data["firstname"];
            this.lastname = _data["lastname"];
            this.password = _data["password"];
            this.email = _data["email"];
            this.isTrainer = _data["isTrainer"];
        }
    }

    static fromJS(data: any): RegisterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstname"] = this.firstname;
        data["lastname"] = this.lastname;
        data["password"] = this.password;
        data["email"] = this.email;
        data["isTrainer"] = this.isTrainer;
        return data;
    }
}

export interface IRegisterViewModel {
    firstname: string;
    lastname: string;
    password?: string | undefined;
    email: string;
    isTrainer?: boolean;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            this.temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}

// @Injectable({
//   providedIn: 'root'
// })
// export class ClientExtensionService {

//   constructor() {
//    }
// }